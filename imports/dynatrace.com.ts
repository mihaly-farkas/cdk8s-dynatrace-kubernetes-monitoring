// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * DynaKube is the Schema for the DynaKube API
 *
 * @schema DynaKube
 */
export class DynaKube extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DynaKube"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dynatrace.com/v1beta1',
    kind: 'DynaKube',
  };

  /**
   * Renders a Kubernetes manifest for "DynaKube".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DynaKubeProps = {}): any {
    return {
      ...DynaKube.GVK,
      ...toJson_DynaKubeProps(props),
    };
  }

  /**
   * Defines a "DynaKube" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DynaKubeProps = {}) {
    super(scope, id, {
      ...DynaKube.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DynaKube.GVK,
      ...toJson_DynaKubeProps(resolved),
    };
  }
}

/**
 * DynaKube is the Schema for the DynaKube API
 *
 * @schema DynaKube
 */
export interface DynaKubeProps {
  /**
   * @schema DynaKube#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DynaKubeSpec defines the desired state of DynaKube
   *
   * @schema DynaKube#spec
   */
  readonly spec?: DynaKubeSpec;

}

/**
 * Converts an object of type 'DynaKubeProps' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeProps(obj: DynaKubeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DynaKubeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * DynaKubeSpec defines the desired state of DynaKube
 *
 * @schema DynaKubeSpec
 */
export interface DynaKubeSpec {
  /**
   * General configuration about ActiveGate instances.
   *
   * @schema DynaKubeSpec#activeGate
   */
  readonly activeGate?: DynaKubeSpecActiveGate;

  /**
   * Dynatrace apiUrl, including the /api path at the end. For SaaS, set YOUR_ENVIRONMENT_ID to your environment ID. For Managed, change the apiUrl address.
   * For instructions on how to determine the environment ID and how to configure the apiUrl address, see Environment ID (https://www.dynatrace.
   *
   * @schema DynaKubeSpec#apiUrl
   */
  readonly apiUrl: string;

  /**
   * Defines a custom pull secret in case you use a private registry when pulling images from the Dynatrace environment.
   * To define a custom pull secret and learn about the expected behavior, see Configure customPullSecret
   * (https://www.dynatrace.
   *
   * @schema DynaKubeSpec#customPullSecret
   */
  readonly customPullSecret?: string;

  /**
   * When enabled, and if Istio is installed on the Kubernetes environment, Dynatrace Operator will create the corresponding
   * VirtualService and ServiceEntry objects to allow access to the Dynatrace Cluster from the OneAgent or ActiveGate.
   * Disabled by default.
   *
   * @schema DynaKubeSpec#enableIstio
   */
  readonly enableIstio?: boolean;

  /**
   * Configuration for Kubernetes Monitoring
   *
   * @schema DynaKubeSpec#kubernetesMonitoring
   */
  readonly kubernetesMonitoring?: DynaKubeSpecKubernetesMonitoring;

  /**
   * Applicable only for applicationMonitoring or cloudNativeFullStack configuration types. The namespaces where you want Dynatrace Operator to inject.
   * For more information, see Configure monitoring for namespaces and pods (https://www.dynatrace.
   *
   * @schema DynaKubeSpec#namespaceSelector
   */
  readonly namespaceSelector?: DynaKubeSpecNamespaceSelector;

  /**
   * Sets a network zone for the OneAgent and ActiveGate pods.
   *
   * @schema DynaKubeSpec#networkZone
   */
  readonly networkZone?: string;

  /**
   * General configuration about OneAgent instances.
   * You can't enable more than one module (classicFullStack, cloudNativeFullStack, hostMonitoring, or applicationMonitoring).
   *
   * @schema DynaKubeSpec#oneAgent
   */
  readonly oneAgent?: DynaKubeSpecOneAgent;

  /**
   * Set custom proxy settings either directly or from a secret with the field proxy.
   * Note: Applies to Dynatrace Operator, ActiveGate, and OneAgents.
   *
   * @schema DynaKubeSpec#proxy
   */
  readonly proxy?: DynaKubeSpecProxy;

  /**
   * Configuration for Routing
   *
   * @schema DynaKubeSpec#routing
   */
  readonly routing?: DynaKubeSpecRouting;

  /**
   * Disable certificate check for the connection between Dynatrace Operator and the Dynatrace Cluster.
   * Set to true if you want to skip certification validation checks.
   *
   * @schema DynaKubeSpec#skipCertCheck
   */
  readonly skipCertCheck?: boolean;

  /**
   * Name of the secret holding the tokens used for connecting to Dynatrace.
   *
   * @schema DynaKubeSpec#tokens
   */
  readonly tokens?: string;

  /**
   * Adds custom RootCAs from a configmap. Put the certificate under certs within your configmap.
   * Note: Applies to Dynatrace Operator, OneAgent and ActiveGate.
   *
   * @schema DynaKubeSpec#trustedCAs
   */
  readonly trustedCAs?: string;

}

/**
 * Converts an object of type 'DynaKubeSpec' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpec(obj: DynaKubeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'activeGate': toJson_DynaKubeSpecActiveGate(obj.activeGate),
    'apiUrl': obj.apiUrl,
    'customPullSecret': obj.customPullSecret,
    'enableIstio': obj.enableIstio,
    'kubernetesMonitoring': toJson_DynaKubeSpecKubernetesMonitoring(obj.kubernetesMonitoring),
    'namespaceSelector': toJson_DynaKubeSpecNamespaceSelector(obj.namespaceSelector),
    'networkZone': obj.networkZone,
    'oneAgent': toJson_DynaKubeSpecOneAgent(obj.oneAgent),
    'proxy': toJson_DynaKubeSpecProxy(obj.proxy),
    'routing': toJson_DynaKubeSpecRouting(obj.routing),
    'skipCertCheck': obj.skipCertCheck,
    'tokens': obj.tokens,
    'trustedCAs': obj.trustedCAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * General configuration about ActiveGate instances.
 *
 * @schema DynaKubeSpecActiveGate
 */
export interface DynaKubeSpecActiveGate {
  /**
   * Adds additional annotations to the ActiveGate pods
   *
   * @schema DynaKubeSpecActiveGate#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Activegate capabilities enabled (routing, kubernetes-monitoring, metrics-ingest, dynatrace-api)
   *
   * @schema DynaKubeSpecActiveGate#capabilities
   */
  readonly capabilities?: string[];

  /**
   * Add a custom properties file by providing it as a value or reference it from a secret
   * If referenced from a secret, make sure the key is called 'customProperties'
   *
   * @schema DynaKubeSpecActiveGate#customProperties
   */
  readonly customProperties?: DynaKubeSpecActiveGateCustomProperties;

  /**
   * Sets DNS Policy for the ActiveGate pods
   *
   * @schema DynaKubeSpecActiveGate#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * List of environment variables to set for the ActiveGate
   *
   * @schema DynaKubeSpecActiveGate#env
   */
  readonly env?: DynaKubeSpecActiveGateEnv[];

  /**
   * Set activation group for ActiveGate
   *
   * @schema DynaKubeSpecActiveGate#group
   */
  readonly group?: string;

  /**
   * The ActiveGate container image. Defaults to the latest ActiveGate image provided by the registry on the tenant
   *
   * @default the latest ActiveGate image provided by the registry on the tenant
   * @schema DynaKubeSpecActiveGate#image
   */
  readonly image?: string;

  /**
   * Adds additional labels for the ActiveGate pods
   *
   * @schema DynaKubeSpecActiveGate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Node selector to control the selection of nodes
   *
   * @schema DynaKubeSpecActiveGate#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * If specified, indicates the pod's priority. Name must be defined by creating a PriorityClass object with that
   * name. If not specified the setting will be removed from the StatefulSet.
   *
   * @schema DynaKubeSpecActiveGate#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Amount of replicas for your ActiveGates
   *
   * @schema DynaKubeSpecActiveGate#replicas
   */
  readonly replicas?: number;

  /**
   * Define resources requests and limits for single ActiveGate pods
   *
   * @schema DynaKubeSpecActiveGate#resources
   */
  readonly resources?: DynaKubeSpecActiveGateResources;

  /**
   * The name of a secret containing ActiveGate TLS cert+key and password. If not set, self-signed certificate is used.
   * server.p12: certificate+key pair in pkcs12 format
   * password: passphrase to read server.p12
   *
   * @schema DynaKubeSpecActiveGate#tlsSecretName
   */
  readonly tlsSecretName?: string;

  /**
   * Set tolerations for the ActiveGate pods
   *
   * @schema DynaKubeSpecActiveGate#tolerations
   */
  readonly tolerations?: DynaKubeSpecActiveGateTolerations[];

  /**
   * Adds TopologySpreadConstraints for the ActiveGate pods
   *
   * @schema DynaKubeSpecActiveGate#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: DynaKubeSpecActiveGateTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'DynaKubeSpecActiveGate' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecActiveGate(obj: DynaKubeSpecActiveGate | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'capabilities': obj.capabilities?.map(y => y),
    'customProperties': toJson_DynaKubeSpecActiveGateCustomProperties(obj.customProperties),
    'dnsPolicy': obj.dnsPolicy,
    'env': obj.env?.map(y => toJson_DynaKubeSpecActiveGateEnv(y)),
    'group': obj.group,
    'image': obj.image,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'priorityClassName': obj.priorityClassName,
    'replicas': obj.replicas,
    'resources': toJson_DynaKubeSpecActiveGateResources(obj.resources),
    'tlsSecretName': obj.tlsSecretName,
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeSpecActiveGateTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_DynaKubeSpecActiveGateTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configuration for Kubernetes Monitoring
 *
 * @schema DynaKubeSpecKubernetesMonitoring
 */
export interface DynaKubeSpecKubernetesMonitoring {
  /**
   * Add a custom properties file by providing it as a value or reference it from a secret
   * If referenced from a secret, make sure the key is called 'customProperties'
   *
   * @schema DynaKubeSpecKubernetesMonitoring#customProperties
   */
  readonly customProperties?: DynaKubeSpecKubernetesMonitoringCustomProperties;

  /**
   * Enables Capability
   *
   * @schema DynaKubeSpecKubernetesMonitoring#enabled
   */
  readonly enabled?: boolean;

  /**
   * List of environment variables to set for the ActiveGate
   *
   * @schema DynaKubeSpecKubernetesMonitoring#env
   */
  readonly env?: DynaKubeSpecKubernetesMonitoringEnv[];

  /**
   * Set activation group for ActiveGate
   *
   * @schema DynaKubeSpecKubernetesMonitoring#group
   */
  readonly group?: string;

  /**
   * The ActiveGate container image. Defaults to the latest ActiveGate image provided by the registry on the tenant
   *
   * @default the latest ActiveGate image provided by the registry on the tenant
   * @schema DynaKubeSpecKubernetesMonitoring#image
   */
  readonly image?: string;

  /**
   * Adds additional labels for the ActiveGate pods
   *
   * @schema DynaKubeSpecKubernetesMonitoring#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Node selector to control the selection of nodes
   *
   * @schema DynaKubeSpecKubernetesMonitoring#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Amount of replicas for your ActiveGates
   *
   * @schema DynaKubeSpecKubernetesMonitoring#replicas
   */
  readonly replicas?: number;

  /**
   * Define resources requests and limits for single ActiveGate pods
   *
   * @schema DynaKubeSpecKubernetesMonitoring#resources
   */
  readonly resources?: DynaKubeSpecKubernetesMonitoringResources;

  /**
   * Set tolerations for the ActiveGate pods
   *
   * @schema DynaKubeSpecKubernetesMonitoring#tolerations
   */
  readonly tolerations?: DynaKubeSpecKubernetesMonitoringTolerations[];

  /**
   * Adds TopologySpreadConstraints for the ActiveGate pods
   *
   * @schema DynaKubeSpecKubernetesMonitoring#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: DynaKubeSpecKubernetesMonitoringTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'DynaKubeSpecKubernetesMonitoring' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecKubernetesMonitoring(obj: DynaKubeSpecKubernetesMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'customProperties': toJson_DynaKubeSpecKubernetesMonitoringCustomProperties(obj.customProperties),
    'enabled': obj.enabled,
    'env': obj.env?.map(y => toJson_DynaKubeSpecKubernetesMonitoringEnv(y)),
    'group': obj.group,
    'image': obj.image,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'replicas': obj.replicas,
    'resources': toJson_DynaKubeSpecKubernetesMonitoringResources(obj.resources),
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeSpecKubernetesMonitoringTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_DynaKubeSpecKubernetesMonitoringTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Applicable only for applicationMonitoring or cloudNativeFullStack configuration types. The namespaces where you want Dynatrace Operator to inject.
 * For more information, see Configure monitoring for namespaces and pods (https://www.dynatrace.
 *
 * @schema DynaKubeSpecNamespaceSelector
 */
export interface DynaKubeSpecNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DynaKubeSpecNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DynaKubeSpecNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DynaKubeSpecNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DynaKubeSpecNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecNamespaceSelector(obj: DynaKubeSpecNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DynaKubeSpecNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * General configuration about OneAgent instances.
 * You can't enable more than one module (classicFullStack, cloudNativeFullStack, hostMonitoring, or applicationMonitoring).
 *
 * @schema DynaKubeSpecOneAgent
 */
export interface DynaKubeSpecOneAgent {
  /**
   * dynatrace-webhook injects into application pods based on labeled namespaces.
   * Has an optional CSI driver per node via DaemonSet to provide binaries to pods.
   *
   * @schema DynaKubeSpecOneAgent#applicationMonitoring
   */
  readonly applicationMonitoring?: DynaKubeSpecOneAgentApplicationMonitoring;

  /**
   * Has a single OneAgent per node via DaemonSet.
   * Injection is performed via the same OneAgent DaemonSet.
   *
   * @schema DynaKubeSpecOneAgent#classicFullStack
   */
  readonly classicFullStack?: DynaKubeSpecOneAgentClassicFullStack;

  /**
   * Has a single OneAgent per node via DaemonSet.
   * dynatrace-webhook injects into application pods based on labeled namespaces.
   * Has a CSI driver per node via DaemonSet to provide binaries to pods.
   *
   * @schema DynaKubeSpecOneAgent#cloudNativeFullStack
   */
  readonly cloudNativeFullStack?: DynaKubeSpecOneAgentCloudNativeFullStack;

  /**
   * Sets a host group for OneAgent.
   *
   * @schema DynaKubeSpecOneAgent#hostGroup
   */
  readonly hostGroup?: string;

  /**
   * Has a single OneAgent per node via DaemonSet.
   * Doesn't inject into application pods.
   *
   * @schema DynaKubeSpecOneAgent#hostMonitoring
   */
  readonly hostMonitoring?: DynaKubeSpecOneAgentHostMonitoring;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgent' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgent(obj: DynaKubeSpecOneAgent | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'applicationMonitoring': toJson_DynaKubeSpecOneAgentApplicationMonitoring(obj.applicationMonitoring),
    'classicFullStack': toJson_DynaKubeSpecOneAgentClassicFullStack(obj.classicFullStack),
    'cloudNativeFullStack': toJson_DynaKubeSpecOneAgentCloudNativeFullStack(obj.cloudNativeFullStack),
    'hostGroup': obj.hostGroup,
    'hostMonitoring': toJson_DynaKubeSpecOneAgentHostMonitoring(obj.hostMonitoring),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Set custom proxy settings either directly or from a secret with the field proxy.
 * Note: Applies to Dynatrace Operator, ActiveGate, and OneAgents.
 *
 * @schema DynaKubeSpecProxy
 */
export interface DynaKubeSpecProxy {
  /**
   * Proxy URL. It has preference over ValueFrom.
   *
   * @schema DynaKubeSpecProxy#value
   */
  readonly value?: string;

  /**
   * Secret containing proxy URL.
   *
   * @schema DynaKubeSpecProxy#valueFrom
   */
  readonly valueFrom?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecProxy' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecProxy(obj: DynaKubeSpecProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'value': obj.value,
    'valueFrom': obj.valueFrom,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configuration for Routing
 *
 * @schema DynaKubeSpecRouting
 */
export interface DynaKubeSpecRouting {
  /**
   * Add a custom properties file by providing it as a value or reference it from a secret
   * If referenced from a secret, make sure the key is called 'customProperties'
   *
   * @schema DynaKubeSpecRouting#customProperties
   */
  readonly customProperties?: DynaKubeSpecRoutingCustomProperties;

  /**
   * Enables Capability
   *
   * @schema DynaKubeSpecRouting#enabled
   */
  readonly enabled?: boolean;

  /**
   * List of environment variables to set for the ActiveGate
   *
   * @schema DynaKubeSpecRouting#env
   */
  readonly env?: DynaKubeSpecRoutingEnv[];

  /**
   * Set activation group for ActiveGate
   *
   * @schema DynaKubeSpecRouting#group
   */
  readonly group?: string;

  /**
   * The ActiveGate container image. Defaults to the latest ActiveGate image provided by the registry on the tenant
   *
   * @default the latest ActiveGate image provided by the registry on the tenant
   * @schema DynaKubeSpecRouting#image
   */
  readonly image?: string;

  /**
   * Adds additional labels for the ActiveGate pods
   *
   * @schema DynaKubeSpecRouting#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Node selector to control the selection of nodes
   *
   * @schema DynaKubeSpecRouting#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Amount of replicas for your ActiveGates
   *
   * @schema DynaKubeSpecRouting#replicas
   */
  readonly replicas?: number;

  /**
   * Define resources requests and limits for single ActiveGate pods
   *
   * @schema DynaKubeSpecRouting#resources
   */
  readonly resources?: DynaKubeSpecRoutingResources;

  /**
   * Set tolerations for the ActiveGate pods
   *
   * @schema DynaKubeSpecRouting#tolerations
   */
  readonly tolerations?: DynaKubeSpecRoutingTolerations[];

  /**
   * Adds TopologySpreadConstraints for the ActiveGate pods
   *
   * @schema DynaKubeSpecRouting#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: DynaKubeSpecRoutingTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'DynaKubeSpecRouting' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecRouting(obj: DynaKubeSpecRouting | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'customProperties': toJson_DynaKubeSpecRoutingCustomProperties(obj.customProperties),
    'enabled': obj.enabled,
    'env': obj.env?.map(y => toJson_DynaKubeSpecRoutingEnv(y)),
    'group': obj.group,
    'image': obj.image,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'replicas': obj.replicas,
    'resources': toJson_DynaKubeSpecRoutingResources(obj.resources),
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeSpecRoutingTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_DynaKubeSpecRoutingTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Add a custom properties file by providing it as a value or reference it from a secret
 * If referenced from a secret, make sure the key is called 'customProperties'
 *
 * @schema DynaKubeSpecActiveGateCustomProperties
 */
export interface DynaKubeSpecActiveGateCustomProperties {
  /**
   * Custom properties value.
   *
   * @schema DynaKubeSpecActiveGateCustomProperties#value
   */
  readonly value?: string;

  /**
   * Custom properties secret.
   *
   * @schema DynaKubeSpecActiveGateCustomProperties#valueFrom
   */
  readonly valueFrom?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecActiveGateCustomProperties' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecActiveGateCustomProperties(obj: DynaKubeSpecActiveGateCustomProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'value': obj.value,
    'valueFrom': obj.valueFrom,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DynaKubeSpecActiveGateEnv
 */
export interface DynaKubeSpecActiveGateEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DynaKubeSpecActiveGateEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged.
   *
   * @schema DynaKubeSpecActiveGateEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DynaKubeSpecActiveGateEnv#valueFrom
   */
  readonly valueFrom?: DynaKubeSpecActiveGateEnvValueFrom;

}

/**
 * Converts an object of type 'DynaKubeSpecActiveGateEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecActiveGateEnv(obj: DynaKubeSpecActiveGateEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DynaKubeSpecActiveGateEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Define resources requests and limits for single ActiveGate pods
 *
 * @schema DynaKubeSpecActiveGateResources
 */
export interface DynaKubeSpecActiveGateResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeSpecActiveGateResources#claims
   */
  readonly claims?: DynaKubeSpecActiveGateResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeSpecActiveGateResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeSpecActiveGateResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeSpecActiveGateResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeSpecActiveGateResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeSpecActiveGateResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecActiveGateResources(obj: DynaKubeSpecActiveGateResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeSpecActiveGateResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeSpecActiveGateTolerations
 */
export interface DynaKubeSpecActiveGateTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeSpecActiveGateTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeSpecActiveGateTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeSpecActiveGateTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeSpecActiveGateTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeSpecActiveGateTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecActiveGateTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecActiveGateTolerations(obj: DynaKubeSpecActiveGateTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema DynaKubeSpecActiveGateTopologySpreadConstraints
 */
export interface DynaKubeSpecActiveGateTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema DynaKubeSpecActiveGateTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated.
   *
   * @schema DynaKubeSpecActiveGateTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   *
   * @schema DynaKubeSpecActiveGateTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   *
   * @schema DynaKubeSpecActiveGateTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored.
   *
   * @schema DynaKubeSpecActiveGateTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * @schema DynaKubeSpecActiveGateTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   *
   * @schema DynaKubeSpecActiveGateTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   *
   * @schema DynaKubeSpecActiveGateTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'DynaKubeSpecActiveGateTopologySpreadConstraints' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecActiveGateTopologySpreadConstraints(obj: DynaKubeSpecActiveGateTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'labelSelector': toJson_DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Add a custom properties file by providing it as a value or reference it from a secret
 * If referenced from a secret, make sure the key is called 'customProperties'
 *
 * @schema DynaKubeSpecKubernetesMonitoringCustomProperties
 */
export interface DynaKubeSpecKubernetesMonitoringCustomProperties {
  /**
   * Custom properties value.
   *
   * @schema DynaKubeSpecKubernetesMonitoringCustomProperties#value
   */
  readonly value?: string;

  /**
   * Custom properties secret.
   *
   * @schema DynaKubeSpecKubernetesMonitoringCustomProperties#valueFrom
   */
  readonly valueFrom?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecKubernetesMonitoringCustomProperties' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecKubernetesMonitoringCustomProperties(obj: DynaKubeSpecKubernetesMonitoringCustomProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'value': obj.value,
    'valueFrom': obj.valueFrom,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DynaKubeSpecKubernetesMonitoringEnv
 */
export interface DynaKubeSpecKubernetesMonitoringEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged.
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnv#valueFrom
   */
  readonly valueFrom?: DynaKubeSpecKubernetesMonitoringEnvValueFrom;

}

/**
 * Converts an object of type 'DynaKubeSpecKubernetesMonitoringEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecKubernetesMonitoringEnv(obj: DynaKubeSpecKubernetesMonitoringEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DynaKubeSpecKubernetesMonitoringEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Define resources requests and limits for single ActiveGate pods
 *
 * @schema DynaKubeSpecKubernetesMonitoringResources
 */
export interface DynaKubeSpecKubernetesMonitoringResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeSpecKubernetesMonitoringResources#claims
   */
  readonly claims?: DynaKubeSpecKubernetesMonitoringResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeSpecKubernetesMonitoringResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeSpecKubernetesMonitoringResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeSpecKubernetesMonitoringResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeSpecKubernetesMonitoringResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeSpecKubernetesMonitoringResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecKubernetesMonitoringResources(obj: DynaKubeSpecKubernetesMonitoringResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeSpecKubernetesMonitoringResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeSpecKubernetesMonitoringTolerations
 */
export interface DynaKubeSpecKubernetesMonitoringTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeSpecKubernetesMonitoringTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeSpecKubernetesMonitoringTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeSpecKubernetesMonitoringTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeSpecKubernetesMonitoringTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeSpecKubernetesMonitoringTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecKubernetesMonitoringTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecKubernetesMonitoringTolerations(obj: DynaKubeSpecKubernetesMonitoringTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema DynaKubeSpecKubernetesMonitoringTopologySpreadConstraints
 */
export interface DynaKubeSpecKubernetesMonitoringTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema DynaKubeSpecKubernetesMonitoringTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated.
   *
   * @schema DynaKubeSpecKubernetesMonitoringTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   *
   * @schema DynaKubeSpecKubernetesMonitoringTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   *
   * @schema DynaKubeSpecKubernetesMonitoringTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored.
   *
   * @schema DynaKubeSpecKubernetesMonitoringTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * @schema DynaKubeSpecKubernetesMonitoringTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   *
   * @schema DynaKubeSpecKubernetesMonitoringTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   *
   * @schema DynaKubeSpecKubernetesMonitoringTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'DynaKubeSpecKubernetesMonitoringTopologySpreadConstraints' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecKubernetesMonitoringTopologySpreadConstraints(obj: DynaKubeSpecKubernetesMonitoringTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'labelSelector': toJson_DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema DynaKubeSpecNamespaceSelectorMatchExpressions
 */
export interface DynaKubeSpecNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DynaKubeSpecNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DynaKubeSpecNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema DynaKubeSpecNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeSpecNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecNamespaceSelectorMatchExpressions(obj: DynaKubeSpecNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * dynatrace-webhook injects into application pods based on labeled namespaces.
 * Has an optional CSI driver per node via DaemonSet to provide binaries to pods.
 *
 * @schema DynaKubeSpecOneAgentApplicationMonitoring
 */
export interface DynaKubeSpecOneAgentApplicationMonitoring {
  /**
   * The OneAgent image that is used to inject into Pods.
   *
   * @schema DynaKubeSpecOneAgentApplicationMonitoring#codeModulesImage
   */
  readonly codeModulesImage?: string;

  /**
   * Define resources requests and limits for the initContainer. For details, see Managing resources for containers
   * (https://kubernetes.io/docs/concepts/configuration/manage-resources-containers).
   *
   * @schema DynaKubeSpecOneAgentApplicationMonitoring#initResources
   */
  readonly initResources?: DynaKubeSpecOneAgentApplicationMonitoringInitResources;

  /**
   * Set if you want to use the CSIDriver. Don't enable it if you do not have access to Kubernetes nodes or if you lack privileges.
   *
   * @schema DynaKubeSpecOneAgentApplicationMonitoring#useCSIDriver
   */
  readonly useCsiDriver?: boolean;

  /**
   * The OneAgent version to be used.
   *
   * @schema DynaKubeSpecOneAgentApplicationMonitoring#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentApplicationMonitoring' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentApplicationMonitoring(obj: DynaKubeSpecOneAgentApplicationMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'codeModulesImage': obj.codeModulesImage,
    'initResources': toJson_DynaKubeSpecOneAgentApplicationMonitoringInitResources(obj.initResources),
    'useCSIDriver': obj.useCsiDriver,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Has a single OneAgent per node via DaemonSet.
 * Injection is performed via the same OneAgent DaemonSet.
 *
 * @schema DynaKubeSpecOneAgentClassicFullStack
 */
export interface DynaKubeSpecOneAgentClassicFullStack {
  /**
   * Add custom OneAgent annotations.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStack#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Set additional arguments to the OneAgent installer.
   * For available options, see Linux custom installation (https://www.dynatrace.com/support/help/setup-and-configuration/dynatrace-oneagent/installation-and-operation/linux/installation/customize-oneagent-installation-on-linux).
   *
   * @schema DynaKubeSpecOneAgentClassicFullStack#args
   */
  readonly args?: string[];

  /**
   * Disables automatic restarts of OneAgent pods in case a new version is available (https://www.dynatrace.com/support/help/setup-and-configuration/setup-on-container-platforms/kubernetes/get-started-with-kubernetes-monitoring#disable-auto).
   * Enabled by default.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStack#autoUpdate
   */
  readonly autoUpdate?: boolean;

  /**
   * Set the DNS Policy for OneAgent pods. For details, see Pods DNS Policy (https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy).
   *
   * @schema DynaKubeSpecOneAgentClassicFullStack#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * Set additional environment variables for the OneAgent pods.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStack#env
   */
  readonly env?: DynaKubeSpecOneAgentClassicFullStackEnv[];

  /**
   * Use a custom OneAgent Docker image. Defaults to the image from the Dynatrace cluster.
   *
   * @default the image from the Dynatrace cluster.
   * @schema DynaKubeSpecOneAgentClassicFullStack#image
   */
  readonly image?: string;

  /**
   * Your defined labels for OneAgent pods in order to structure workloads as desired.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStack#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Specify the node selector that controls on which nodes OneAgent will be deployed.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStack#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
   * Note: resource.requests shows the values needed to run; resource.limits shows the maximum limits for the pod.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStack#oneAgentResources
   */
  readonly oneAgentResources?: DynaKubeSpecOneAgentClassicFullStackOneAgentResources;

  /**
   * Assign a priority class to the OneAgent pods. By default, no class is set.
   * For details, see Pod Priority and Preemption (https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/).
   *
   * @schema DynaKubeSpecOneAgentClassicFullStack#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Tolerations to include with the OneAgent DaemonSet. For details, see Taints and Tolerations (https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/).
   *
   * @schema DynaKubeSpecOneAgentClassicFullStack#tolerations
   */
  readonly tolerations?: DynaKubeSpecOneAgentClassicFullStackTolerations[];

  /**
   * The OneAgent version to be used.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStack#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentClassicFullStack' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentClassicFullStack(obj: DynaKubeSpecOneAgentClassicFullStack | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'args': obj.args?.map(y => y),
    'autoUpdate': obj.autoUpdate,
    'dnsPolicy': obj.dnsPolicy,
    'env': obj.env?.map(y => toJson_DynaKubeSpecOneAgentClassicFullStackEnv(y)),
    'image': obj.image,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'oneAgentResources': toJson_DynaKubeSpecOneAgentClassicFullStackOneAgentResources(obj.oneAgentResources),
    'priorityClassName': obj.priorityClassName,
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeSpecOneAgentClassicFullStackTolerations(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Has a single OneAgent per node via DaemonSet.
 * dynatrace-webhook injects into application pods based on labeled namespaces.
 * Has a CSI driver per node via DaemonSet to provide binaries to pods.
 *
 * @schema DynaKubeSpecOneAgentCloudNativeFullStack
 */
export interface DynaKubeSpecOneAgentCloudNativeFullStack {
  /**
   * Add custom OneAgent annotations.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStack#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Set additional arguments to the OneAgent installer.
   * For available options, see Linux custom installation (https://www.dynatrace.com/support/help/setup-and-configuration/dynatrace-oneagent/installation-and-operation/linux/installation/customize-oneagent-installation-on-linux).
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStack#args
   */
  readonly args?: string[];

  /**
   * Disables automatic restarts of OneAgent pods in case a new version is available (https://www.dynatrace.com/support/help/setup-and-configuration/setup-on-container-platforms/kubernetes/get-started-with-kubernetes-monitoring#disable-auto).
   * Enabled by default.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStack#autoUpdate
   */
  readonly autoUpdate?: boolean;

  /**
   * The OneAgent image that is used to inject into Pods.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStack#codeModulesImage
   */
  readonly codeModulesImage?: string;

  /**
   * Set the DNS Policy for OneAgent pods. For details, see Pods DNS Policy (https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy).
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStack#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * Set additional environment variables for the OneAgent pods.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStack#env
   */
  readonly env?: DynaKubeSpecOneAgentCloudNativeFullStackEnv[];

  /**
   * Use a custom OneAgent Docker image. Defaults to the image from the Dynatrace cluster.
   *
   * @default the image from the Dynatrace cluster.
   * @schema DynaKubeSpecOneAgentCloudNativeFullStack#image
   */
  readonly image?: string;

  /**
   * Define resources requests and limits for the initContainer. For details, see Managing resources for containers
   * (https://kubernetes.io/docs/concepts/configuration/manage-resources-containers).
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStack#initResources
   */
  readonly initResources?: DynaKubeSpecOneAgentCloudNativeFullStackInitResources;

  /**
   * Your defined labels for OneAgent pods in order to structure workloads as desired.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStack#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Specify the node selector that controls on which nodes OneAgent will be deployed.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStack#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
   * Note: resource.requests shows the values needed to run; resource.limits shows the maximum limits for the pod.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStack#oneAgentResources
   */
  readonly oneAgentResources?: DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResources;

  /**
   * Assign a priority class to the OneAgent pods. By default, no class is set.
   * For details, see Pod Priority and Preemption (https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/).
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStack#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Tolerations to include with the OneAgent DaemonSet. For details, see Taints and Tolerations (https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/).
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStack#tolerations
   */
  readonly tolerations?: DynaKubeSpecOneAgentCloudNativeFullStackTolerations[];

  /**
   * The OneAgent version to be used.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStack#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentCloudNativeFullStack' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentCloudNativeFullStack(obj: DynaKubeSpecOneAgentCloudNativeFullStack | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'args': obj.args?.map(y => y),
    'autoUpdate': obj.autoUpdate,
    'codeModulesImage': obj.codeModulesImage,
    'dnsPolicy': obj.dnsPolicy,
    'env': obj.env?.map(y => toJson_DynaKubeSpecOneAgentCloudNativeFullStackEnv(y)),
    'image': obj.image,
    'initResources': toJson_DynaKubeSpecOneAgentCloudNativeFullStackInitResources(obj.initResources),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'oneAgentResources': toJson_DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResources(obj.oneAgentResources),
    'priorityClassName': obj.priorityClassName,
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeSpecOneAgentCloudNativeFullStackTolerations(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Has a single OneAgent per node via DaemonSet.
 * Doesn't inject into application pods.
 *
 * @schema DynaKubeSpecOneAgentHostMonitoring
 */
export interface DynaKubeSpecOneAgentHostMonitoring {
  /**
   * Add custom OneAgent annotations.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoring#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Set additional arguments to the OneAgent installer.
   * For available options, see Linux custom installation (https://www.dynatrace.com/support/help/setup-and-configuration/dynatrace-oneagent/installation-and-operation/linux/installation/customize-oneagent-installation-on-linux).
   *
   * @schema DynaKubeSpecOneAgentHostMonitoring#args
   */
  readonly args?: string[];

  /**
   * Disables automatic restarts of OneAgent pods in case a new version is available (https://www.dynatrace.com/support/help/setup-and-configuration/setup-on-container-platforms/kubernetes/get-started-with-kubernetes-monitoring#disable-auto).
   * Enabled by default.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoring#autoUpdate
   */
  readonly autoUpdate?: boolean;

  /**
   * Set the DNS Policy for OneAgent pods. For details, see Pods DNS Policy (https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy).
   *
   * @schema DynaKubeSpecOneAgentHostMonitoring#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * Set additional environment variables for the OneAgent pods.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoring#env
   */
  readonly env?: DynaKubeSpecOneAgentHostMonitoringEnv[];

  /**
   * Use a custom OneAgent Docker image. Defaults to the image from the Dynatrace cluster.
   *
   * @default the image from the Dynatrace cluster.
   * @schema DynaKubeSpecOneAgentHostMonitoring#image
   */
  readonly image?: string;

  /**
   * Your defined labels for OneAgent pods in order to structure workloads as desired.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoring#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Specify the node selector that controls on which nodes OneAgent will be deployed.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoring#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
   * Note: resource.requests shows the values needed to run; resource.limits shows the maximum limits for the pod.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoring#oneAgentResources
   */
  readonly oneAgentResources?: DynaKubeSpecOneAgentHostMonitoringOneAgentResources;

  /**
   * Assign a priority class to the OneAgent pods. By default, no class is set.
   * For details, see Pod Priority and Preemption (https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/).
   *
   * @schema DynaKubeSpecOneAgentHostMonitoring#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Tolerations to include with the OneAgent DaemonSet. For details, see Taints and Tolerations (https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/).
   *
   * @schema DynaKubeSpecOneAgentHostMonitoring#tolerations
   */
  readonly tolerations?: DynaKubeSpecOneAgentHostMonitoringTolerations[];

  /**
   * The OneAgent version to be used.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoring#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentHostMonitoring' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentHostMonitoring(obj: DynaKubeSpecOneAgentHostMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'args': obj.args?.map(y => y),
    'autoUpdate': obj.autoUpdate,
    'dnsPolicy': obj.dnsPolicy,
    'env': obj.env?.map(y => toJson_DynaKubeSpecOneAgentHostMonitoringEnv(y)),
    'image': obj.image,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'oneAgentResources': toJson_DynaKubeSpecOneAgentHostMonitoringOneAgentResources(obj.oneAgentResources),
    'priorityClassName': obj.priorityClassName,
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeSpecOneAgentHostMonitoringTolerations(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Add a custom properties file by providing it as a value or reference it from a secret
 * If referenced from a secret, make sure the key is called 'customProperties'
 *
 * @schema DynaKubeSpecRoutingCustomProperties
 */
export interface DynaKubeSpecRoutingCustomProperties {
  /**
   * Custom properties value.
   *
   * @schema DynaKubeSpecRoutingCustomProperties#value
   */
  readonly value?: string;

  /**
   * Custom properties secret.
   *
   * @schema DynaKubeSpecRoutingCustomProperties#valueFrom
   */
  readonly valueFrom?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecRoutingCustomProperties' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecRoutingCustomProperties(obj: DynaKubeSpecRoutingCustomProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'value': obj.value,
    'valueFrom': obj.valueFrom,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DynaKubeSpecRoutingEnv
 */
export interface DynaKubeSpecRoutingEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DynaKubeSpecRoutingEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged.
   *
   * @schema DynaKubeSpecRoutingEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DynaKubeSpecRoutingEnv#valueFrom
   */
  readonly valueFrom?: DynaKubeSpecRoutingEnvValueFrom;

}

/**
 * Converts an object of type 'DynaKubeSpecRoutingEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecRoutingEnv(obj: DynaKubeSpecRoutingEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DynaKubeSpecRoutingEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Define resources requests and limits for single ActiveGate pods
 *
 * @schema DynaKubeSpecRoutingResources
 */
export interface DynaKubeSpecRoutingResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeSpecRoutingResources#claims
   */
  readonly claims?: DynaKubeSpecRoutingResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeSpecRoutingResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeSpecRoutingResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeSpecRoutingResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeSpecRoutingResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeSpecRoutingResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecRoutingResources(obj: DynaKubeSpecRoutingResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeSpecRoutingResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeSpecRoutingTolerations
 */
export interface DynaKubeSpecRoutingTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeSpecRoutingTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeSpecRoutingTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeSpecRoutingTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeSpecRoutingTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeSpecRoutingTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecRoutingTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecRoutingTolerations(obj: DynaKubeSpecRoutingTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema DynaKubeSpecRoutingTopologySpreadConstraints
 */
export interface DynaKubeSpecRoutingTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema DynaKubeSpecRoutingTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated.
   *
   * @schema DynaKubeSpecRoutingTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   *
   * @schema DynaKubeSpecRoutingTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   *
   * @schema DynaKubeSpecRoutingTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored.
   *
   * @schema DynaKubeSpecRoutingTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * @schema DynaKubeSpecRoutingTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   *
   * @schema DynaKubeSpecRoutingTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   *
   * @schema DynaKubeSpecRoutingTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'DynaKubeSpecRoutingTopologySpreadConstraints' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecRoutingTopologySpreadConstraints(obj: DynaKubeSpecRoutingTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'labelSelector': toJson_DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DynaKubeSpecActiveGateEnvValueFrom
 */
export interface DynaKubeSpecActiveGateEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DynaKubeSpecActiveGateEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DynaKubeSpecActiveGateEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DynaKubeSpecActiveGateEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DynaKubeSpecActiveGateEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DynaKubeSpecActiveGateEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DynaKubeSpecActiveGateEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DynaKubeSpecActiveGateEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DynaKubeSpecActiveGateEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DynaKubeSpecActiveGateEnvValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecActiveGateEnvValueFrom(obj: DynaKubeSpecActiveGateEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'configMapKeyRef': toJson_DynaKubeSpecActiveGateEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DynaKubeSpecActiveGateEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DynaKubeSpecActiveGateEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DynaKubeSpecActiveGateEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeSpecActiveGateResourcesClaims
 */
export interface DynaKubeSpecActiveGateResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeSpecActiveGateResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeSpecActiveGateResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecActiveGateResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecActiveGateResourcesClaims(obj: DynaKubeSpecActiveGateResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeSpecActiveGateResourcesLimits
 */
export class DynaKubeSpecActiveGateResourcesLimits {
  public static fromNumber(value: number): DynaKubeSpecActiveGateResourcesLimits {
    return new DynaKubeSpecActiveGateResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeSpecActiveGateResourcesLimits {
    return new DynaKubeSpecActiveGateResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeSpecActiveGateResourcesRequests
 */
export class DynaKubeSpecActiveGateResourcesRequests {
  public static fromNumber(value: number): DynaKubeSpecActiveGateResourcesRequests {
    return new DynaKubeSpecActiveGateResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeSpecActiveGateResourcesRequests {
    return new DynaKubeSpecActiveGateResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelector
 */
export interface DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelector(obj: DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DynaKubeSpecKubernetesMonitoringEnvValueFrom
 */
export interface DynaKubeSpecKubernetesMonitoringEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DynaKubeSpecKubernetesMonitoringEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DynaKubeSpecKubernetesMonitoringEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DynaKubeSpecKubernetesMonitoringEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DynaKubeSpecKubernetesMonitoringEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DynaKubeSpecKubernetesMonitoringEnvValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecKubernetesMonitoringEnvValueFrom(obj: DynaKubeSpecKubernetesMonitoringEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'configMapKeyRef': toJson_DynaKubeSpecKubernetesMonitoringEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DynaKubeSpecKubernetesMonitoringEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DynaKubeSpecKubernetesMonitoringEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DynaKubeSpecKubernetesMonitoringEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeSpecKubernetesMonitoringResourcesClaims
 */
export interface DynaKubeSpecKubernetesMonitoringResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeSpecKubernetesMonitoringResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeSpecKubernetesMonitoringResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecKubernetesMonitoringResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecKubernetesMonitoringResourcesClaims(obj: DynaKubeSpecKubernetesMonitoringResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeSpecKubernetesMonitoringResourcesLimits
 */
export class DynaKubeSpecKubernetesMonitoringResourcesLimits {
  public static fromNumber(value: number): DynaKubeSpecKubernetesMonitoringResourcesLimits {
    return new DynaKubeSpecKubernetesMonitoringResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeSpecKubernetesMonitoringResourcesLimits {
    return new DynaKubeSpecKubernetesMonitoringResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeSpecKubernetesMonitoringResourcesRequests
 */
export class DynaKubeSpecKubernetesMonitoringResourcesRequests {
  public static fromNumber(value: number): DynaKubeSpecKubernetesMonitoringResourcesRequests {
    return new DynaKubeSpecKubernetesMonitoringResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeSpecKubernetesMonitoringResourcesRequests {
    return new DynaKubeSpecKubernetesMonitoringResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelector
 */
export interface DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelector(obj: DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Define resources requests and limits for the initContainer. For details, see Managing resources for containers
 * (https://kubernetes.io/docs/concepts/configuration/manage-resources-containers).
 *
 * @schema DynaKubeSpecOneAgentApplicationMonitoringInitResources
 */
export interface DynaKubeSpecOneAgentApplicationMonitoringInitResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeSpecOneAgentApplicationMonitoringInitResources#claims
   */
  readonly claims?: DynaKubeSpecOneAgentApplicationMonitoringInitResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeSpecOneAgentApplicationMonitoringInitResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeSpecOneAgentApplicationMonitoringInitResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeSpecOneAgentApplicationMonitoringInitResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeSpecOneAgentApplicationMonitoringInitResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentApplicationMonitoringInitResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentApplicationMonitoringInitResources(obj: DynaKubeSpecOneAgentApplicationMonitoringInitResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeSpecOneAgentApplicationMonitoringInitResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DynaKubeSpecOneAgentClassicFullStackEnv
 */
export interface DynaKubeSpecOneAgentClassicFullStackEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnv#valueFrom
   */
  readonly valueFrom?: DynaKubeSpecOneAgentClassicFullStackEnvValueFrom;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentClassicFullStackEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentClassicFullStackEnv(obj: DynaKubeSpecOneAgentClassicFullStackEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DynaKubeSpecOneAgentClassicFullStackEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
 * Note: resource.requests shows the values needed to run; resource.limits shows the maximum limits for the pod.
 *
 * @schema DynaKubeSpecOneAgentClassicFullStackOneAgentResources
 */
export interface DynaKubeSpecOneAgentClassicFullStackOneAgentResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackOneAgentResources#claims
   */
  readonly claims?: DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackOneAgentResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackOneAgentResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentClassicFullStackOneAgentResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentClassicFullStackOneAgentResources(obj: DynaKubeSpecOneAgentClassicFullStackOneAgentResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeSpecOneAgentClassicFullStackTolerations
 */
export interface DynaKubeSpecOneAgentClassicFullStackTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeSpecOneAgentClassicFullStackTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentClassicFullStackTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentClassicFullStackTolerations(obj: DynaKubeSpecOneAgentClassicFullStackTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnv
 */
export interface DynaKubeSpecOneAgentCloudNativeFullStackEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnv#valueFrom
   */
  readonly valueFrom?: DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFrom;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentCloudNativeFullStackEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentCloudNativeFullStackEnv(obj: DynaKubeSpecOneAgentCloudNativeFullStackEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Define resources requests and limits for the initContainer. For details, see Managing resources for containers
 * (https://kubernetes.io/docs/concepts/configuration/manage-resources-containers).
 *
 * @schema DynaKubeSpecOneAgentCloudNativeFullStackInitResources
 */
export interface DynaKubeSpecOneAgentCloudNativeFullStackInitResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackInitResources#claims
   */
  readonly claims?: DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackInitResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackInitResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentCloudNativeFullStackInitResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentCloudNativeFullStackInitResources(obj: DynaKubeSpecOneAgentCloudNativeFullStackInitResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
 * Note: resource.requests shows the values needed to run; resource.limits shows the maximum limits for the pod.
 *
 * @schema DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResources
 */
export interface DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResources#claims
   */
  readonly claims?: DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResources(obj: DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeSpecOneAgentCloudNativeFullStackTolerations
 */
export interface DynaKubeSpecOneAgentCloudNativeFullStackTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentCloudNativeFullStackTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentCloudNativeFullStackTolerations(obj: DynaKubeSpecOneAgentCloudNativeFullStackTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DynaKubeSpecOneAgentHostMonitoringEnv
 */
export interface DynaKubeSpecOneAgentHostMonitoringEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnv#valueFrom
   */
  readonly valueFrom?: DynaKubeSpecOneAgentHostMonitoringEnvValueFrom;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentHostMonitoringEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentHostMonitoringEnv(obj: DynaKubeSpecOneAgentHostMonitoringEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DynaKubeSpecOneAgentHostMonitoringEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
 * Note: resource.requests shows the values needed to run; resource.limits shows the maximum limits for the pod.
 *
 * @schema DynaKubeSpecOneAgentHostMonitoringOneAgentResources
 */
export interface DynaKubeSpecOneAgentHostMonitoringOneAgentResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringOneAgentResources#claims
   */
  readonly claims?: DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringOneAgentResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringOneAgentResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentHostMonitoringOneAgentResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentHostMonitoringOneAgentResources(obj: DynaKubeSpecOneAgentHostMonitoringOneAgentResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeSpecOneAgentHostMonitoringTolerations
 */
export interface DynaKubeSpecOneAgentHostMonitoringTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeSpecOneAgentHostMonitoringTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentHostMonitoringTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentHostMonitoringTolerations(obj: DynaKubeSpecOneAgentHostMonitoringTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DynaKubeSpecRoutingEnvValueFrom
 */
export interface DynaKubeSpecRoutingEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DynaKubeSpecRoutingEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DynaKubeSpecRoutingEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DynaKubeSpecRoutingEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DynaKubeSpecRoutingEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DynaKubeSpecRoutingEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DynaKubeSpecRoutingEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DynaKubeSpecRoutingEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DynaKubeSpecRoutingEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DynaKubeSpecRoutingEnvValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecRoutingEnvValueFrom(obj: DynaKubeSpecRoutingEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'configMapKeyRef': toJson_DynaKubeSpecRoutingEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DynaKubeSpecRoutingEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DynaKubeSpecRoutingEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DynaKubeSpecRoutingEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeSpecRoutingResourcesClaims
 */
export interface DynaKubeSpecRoutingResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeSpecRoutingResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeSpecRoutingResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecRoutingResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecRoutingResourcesClaims(obj: DynaKubeSpecRoutingResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeSpecRoutingResourcesLimits
 */
export class DynaKubeSpecRoutingResourcesLimits {
  public static fromNumber(value: number): DynaKubeSpecRoutingResourcesLimits {
    return new DynaKubeSpecRoutingResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeSpecRoutingResourcesLimits {
    return new DynaKubeSpecRoutingResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeSpecRoutingResourcesRequests
 */
export class DynaKubeSpecRoutingResourcesRequests {
  public static fromNumber(value: number): DynaKubeSpecRoutingResourcesRequests {
    return new DynaKubeSpecRoutingResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeSpecRoutingResourcesRequests {
    return new DynaKubeSpecRoutingResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelector
 */
export interface DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelector(obj: DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DynaKubeSpecActiveGateEnvValueFromConfigMapKeyRef
 */
export interface DynaKubeSpecActiveGateEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DynaKubeSpecActiveGateEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeSpecActiveGateEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DynaKubeSpecActiveGateEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeSpecActiveGateEnvValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecActiveGateEnvValueFromConfigMapKeyRef(obj: DynaKubeSpecActiveGateEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DynaKubeSpecActiveGateEnvValueFromFieldRef
 */
export interface DynaKubeSpecActiveGateEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DynaKubeSpecActiveGateEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DynaKubeSpecActiveGateEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DynaKubeSpecActiveGateEnvValueFromFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecActiveGateEnvValueFromFieldRef(obj: DynaKubeSpecActiveGateEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DynaKubeSpecActiveGateEnvValueFromResourceFieldRef
 */
export interface DynaKubeSpecActiveGateEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DynaKubeSpecActiveGateEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DynaKubeSpecActiveGateEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DynaKubeSpecActiveGateEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DynaKubeSpecActiveGateEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DynaKubeSpecActiveGateEnvValueFromResourceFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecActiveGateEnvValueFromResourceFieldRef(obj: DynaKubeSpecActiveGateEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DynaKubeSpecActiveGateEnvValueFromSecretKeyRef
 */
export interface DynaKubeSpecActiveGateEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DynaKubeSpecActiveGateEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeSpecActiveGateEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DynaKubeSpecActiveGateEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeSpecActiveGateEnvValueFromSecretKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecActiveGateEnvValueFromSecretKeyRef(obj: DynaKubeSpecActiveGateEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: DynaKubeSpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DynaKubeSpecKubernetesMonitoringEnvValueFromConfigMapKeyRef
 */
export interface DynaKubeSpecKubernetesMonitoringEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeSpecKubernetesMonitoringEnvValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecKubernetesMonitoringEnvValueFromConfigMapKeyRef(obj: DynaKubeSpecKubernetesMonitoringEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DynaKubeSpecKubernetesMonitoringEnvValueFromFieldRef
 */
export interface DynaKubeSpecKubernetesMonitoringEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DynaKubeSpecKubernetesMonitoringEnvValueFromFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecKubernetesMonitoringEnvValueFromFieldRef(obj: DynaKubeSpecKubernetesMonitoringEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DynaKubeSpecKubernetesMonitoringEnvValueFromResourceFieldRef
 */
export interface DynaKubeSpecKubernetesMonitoringEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DynaKubeSpecKubernetesMonitoringEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DynaKubeSpecKubernetesMonitoringEnvValueFromResourceFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecKubernetesMonitoringEnvValueFromResourceFieldRef(obj: DynaKubeSpecKubernetesMonitoringEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DynaKubeSpecKubernetesMonitoringEnvValueFromSecretKeyRef
 */
export interface DynaKubeSpecKubernetesMonitoringEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DynaKubeSpecKubernetesMonitoringEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeSpecKubernetesMonitoringEnvValueFromSecretKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecKubernetesMonitoringEnvValueFromSecretKeyRef(obj: DynaKubeSpecKubernetesMonitoringEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: DynaKubeSpecKubernetesMonitoringTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeSpecOneAgentApplicationMonitoringInitResourcesClaims
 */
export interface DynaKubeSpecOneAgentApplicationMonitoringInitResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeSpecOneAgentApplicationMonitoringInitResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeSpecOneAgentApplicationMonitoringInitResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentApplicationMonitoringInitResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentApplicationMonitoringInitResourcesClaims(obj: DynaKubeSpecOneAgentApplicationMonitoringInitResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeSpecOneAgentApplicationMonitoringInitResourcesLimits
 */
export class DynaKubeSpecOneAgentApplicationMonitoringInitResourcesLimits {
  public static fromNumber(value: number): DynaKubeSpecOneAgentApplicationMonitoringInitResourcesLimits {
    return new DynaKubeSpecOneAgentApplicationMonitoringInitResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeSpecOneAgentApplicationMonitoringInitResourcesLimits {
    return new DynaKubeSpecOneAgentApplicationMonitoringInitResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeSpecOneAgentApplicationMonitoringInitResourcesRequests
 */
export class DynaKubeSpecOneAgentApplicationMonitoringInitResourcesRequests {
  public static fromNumber(value: number): DynaKubeSpecOneAgentApplicationMonitoringInitResourcesRequests {
    return new DynaKubeSpecOneAgentApplicationMonitoringInitResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeSpecOneAgentApplicationMonitoringInitResourcesRequests {
    return new DynaKubeSpecOneAgentApplicationMonitoringInitResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFrom
 */
export interface DynaKubeSpecOneAgentClassicFullStackEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DynaKubeSpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DynaKubeSpecOneAgentClassicFullStackEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DynaKubeSpecOneAgentClassicFullStackEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DynaKubeSpecOneAgentClassicFullStackEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentClassicFullStackEnvValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentClassicFullStackEnvValueFrom(obj: DynaKubeSpecOneAgentClassicFullStackEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'configMapKeyRef': toJson_DynaKubeSpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DynaKubeSpecOneAgentClassicFullStackEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DynaKubeSpecOneAgentClassicFullStackEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DynaKubeSpecOneAgentClassicFullStackEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesClaims
 */
export interface DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesClaims(obj: DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesLimits
 */
export class DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesLimits {
  public static fromNumber(value: number): DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesLimits {
    return new DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesLimits {
    return new DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesRequests
 */
export class DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesRequests {
  public static fromNumber(value: number): DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesRequests {
    return new DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesRequests {
    return new DynaKubeSpecOneAgentClassicFullStackOneAgentResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFrom
 */
export interface DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFrom(obj: DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'configMapKeyRef': toJson_DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesClaims
 */
export interface DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesClaims(obj: DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesLimits
 */
export class DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesLimits {
  public static fromNumber(value: number): DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesLimits {
    return new DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesLimits {
    return new DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesRequests
 */
export class DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesRequests {
  public static fromNumber(value: number): DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesRequests {
    return new DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesRequests {
    return new DynaKubeSpecOneAgentCloudNativeFullStackInitResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesClaims
 */
export interface DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesClaims(obj: DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesLimits
 */
export class DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesLimits {
  public static fromNumber(value: number): DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesLimits {
    return new DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesLimits {
    return new DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesRequests
 */
export class DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesRequests {
  public static fromNumber(value: number): DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesRequests {
    return new DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesRequests {
    return new DynaKubeSpecOneAgentCloudNativeFullStackOneAgentResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFrom
 */
export interface DynaKubeSpecOneAgentHostMonitoringEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DynaKubeSpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DynaKubeSpecOneAgentHostMonitoringEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DynaKubeSpecOneAgentHostMonitoringEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DynaKubeSpecOneAgentHostMonitoringEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentHostMonitoringEnvValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentHostMonitoringEnvValueFrom(obj: DynaKubeSpecOneAgentHostMonitoringEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'configMapKeyRef': toJson_DynaKubeSpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DynaKubeSpecOneAgentHostMonitoringEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DynaKubeSpecOneAgentHostMonitoringEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DynaKubeSpecOneAgentHostMonitoringEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesClaims
 */
export interface DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesClaims(obj: DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesLimits
 */
export class DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesLimits {
  public static fromNumber(value: number): DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesLimits {
    return new DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesLimits {
    return new DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesRequests
 */
export class DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesRequests {
  public static fromNumber(value: number): DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesRequests {
    return new DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesRequests {
    return new DynaKubeSpecOneAgentHostMonitoringOneAgentResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DynaKubeSpecRoutingEnvValueFromConfigMapKeyRef
 */
export interface DynaKubeSpecRoutingEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DynaKubeSpecRoutingEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeSpecRoutingEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DynaKubeSpecRoutingEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeSpecRoutingEnvValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecRoutingEnvValueFromConfigMapKeyRef(obj: DynaKubeSpecRoutingEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DynaKubeSpecRoutingEnvValueFromFieldRef
 */
export interface DynaKubeSpecRoutingEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DynaKubeSpecRoutingEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DynaKubeSpecRoutingEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DynaKubeSpecRoutingEnvValueFromFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecRoutingEnvValueFromFieldRef(obj: DynaKubeSpecRoutingEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DynaKubeSpecRoutingEnvValueFromResourceFieldRef
 */
export interface DynaKubeSpecRoutingEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DynaKubeSpecRoutingEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DynaKubeSpecRoutingEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DynaKubeSpecRoutingEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DynaKubeSpecRoutingEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DynaKubeSpecRoutingEnvValueFromResourceFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecRoutingEnvValueFromResourceFieldRef(obj: DynaKubeSpecRoutingEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DynaKubeSpecRoutingEnvValueFromSecretKeyRef
 */
export interface DynaKubeSpecRoutingEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DynaKubeSpecRoutingEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeSpecRoutingEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DynaKubeSpecRoutingEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeSpecRoutingEnvValueFromSecretKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecRoutingEnvValueFromSecretKeyRef(obj: DynaKubeSpecRoutingEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: DynaKubeSpecRoutingTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DynaKubeSpecActiveGateEnvValueFromResourceFieldRefDivisor
 */
export class DynaKubeSpecActiveGateEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DynaKubeSpecActiveGateEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeSpecActiveGateEnvValueFromResourceFieldRefDivisor(value);
  }

  public static fromString(value: string): DynaKubeSpecActiveGateEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeSpecActiveGateEnvValueFromResourceFieldRefDivisor(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DynaKubeSpecKubernetesMonitoringEnvValueFromResourceFieldRefDivisor
 */
export class DynaKubeSpecKubernetesMonitoringEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DynaKubeSpecKubernetesMonitoringEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeSpecKubernetesMonitoringEnvValueFromResourceFieldRefDivisor(value);
  }

  public static fromString(value: string): DynaKubeSpecKubernetesMonitoringEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeSpecKubernetesMonitoringEnvValueFromResourceFieldRefDivisor(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef
 */
export interface DynaKubeSpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef(obj: DynaKubeSpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFromFieldRef
 */
export interface DynaKubeSpecOneAgentClassicFullStackEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentClassicFullStackEnvValueFromFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentClassicFullStackEnvValueFromFieldRef(obj: DynaKubeSpecOneAgentClassicFullStackEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFromResourceFieldRef
 */
export interface DynaKubeSpecOneAgentClassicFullStackEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DynaKubeSpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentClassicFullStackEnvValueFromResourceFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentClassicFullStackEnvValueFromResourceFieldRef(obj: DynaKubeSpecOneAgentClassicFullStackEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFromSecretKeyRef
 */
export interface DynaKubeSpecOneAgentClassicFullStackEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentClassicFullStackEnvValueFromSecretKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentClassicFullStackEnvValueFromSecretKeyRef(obj: DynaKubeSpecOneAgentClassicFullStackEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef
 */
export interface DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef(obj: DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromFieldRef
 */
export interface DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromFieldRef(obj: DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef
 */
export interface DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef(obj: DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef
 */
export interface DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef(obj: DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef
 */
export interface DynaKubeSpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef(obj: DynaKubeSpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFromFieldRef
 */
export interface DynaKubeSpecOneAgentHostMonitoringEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentHostMonitoringEnvValueFromFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentHostMonitoringEnvValueFromFieldRef(obj: DynaKubeSpecOneAgentHostMonitoringEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFromResourceFieldRef
 */
export interface DynaKubeSpecOneAgentHostMonitoringEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DynaKubeSpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentHostMonitoringEnvValueFromResourceFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentHostMonitoringEnvValueFromResourceFieldRef(obj: DynaKubeSpecOneAgentHostMonitoringEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFromSecretKeyRef
 */
export interface DynaKubeSpecOneAgentHostMonitoringEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeSpecOneAgentHostMonitoringEnvValueFromSecretKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeSpecOneAgentHostMonitoringEnvValueFromSecretKeyRef(obj: DynaKubeSpecOneAgentHostMonitoringEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DynaKubeSpecRoutingEnvValueFromResourceFieldRefDivisor
 */
export class DynaKubeSpecRoutingEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DynaKubeSpecRoutingEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeSpecRoutingEnvValueFromResourceFieldRefDivisor(value);
  }

  public static fromString(value: string): DynaKubeSpecRoutingEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeSpecRoutingEnvValueFromResourceFieldRefDivisor(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DynaKubeSpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor
 */
export class DynaKubeSpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DynaKubeSpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeSpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor(value);
  }

  public static fromString(value: string): DynaKubeSpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeSpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor
 */
export class DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor(value);
  }

  public static fromString(value: string): DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeSpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DynaKubeSpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor
 */
export class DynaKubeSpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DynaKubeSpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeSpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor(value);
  }

  public static fromString(value: string): DynaKubeSpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeSpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor(value);
  }

  private constructor(public readonly value: number | string) {
  }
}


/**
 * DynaKube is the Schema for the DynaKube API
 *
 * @schema DynaKubeV1Beta2
 */
export class DynaKubeV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DynaKubeV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dynatrace.com/v1beta2',
    kind: 'DynaKube',
  };

  /**
   * Renders a Kubernetes manifest for "DynaKubeV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DynaKubeV1Beta2Props = {}): any {
    return {
      ...DynaKubeV1Beta2.GVK,
      ...toJson_DynaKubeV1Beta2Props(props),
    };
  }

  /**
   * Defines a "DynaKubeV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DynaKubeV1Beta2Props = {}) {
    super(scope, id, {
      ...DynaKubeV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DynaKubeV1Beta2.GVK,
      ...toJson_DynaKubeV1Beta2Props(resolved),
    };
  }
}

/**
 * DynaKube is the Schema for the DynaKube API
 *
 * @schema DynaKubeV1Beta2
 */
export interface DynaKubeV1Beta2Props {
  /**
   * @schema DynaKubeV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DynaKubeSpec defines the desired state of DynaKube
   *
   * @schema DynaKubeV1Beta2#spec
   */
  readonly spec?: DynaKubeV1Beta2Spec;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2Props' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2Props(obj: DynaKubeV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DynaKubeV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * DynaKubeSpec defines the desired state of DynaKube
 *
 * @schema DynaKubeV1Beta2Spec
 */
export interface DynaKubeV1Beta2Spec {
  /**
   * General configuration about ActiveGate instances.
   *
   * @schema DynaKubeV1Beta2Spec#activeGate
   */
  readonly activeGate?: DynaKubeV1Beta2SpecActiveGate;

  /**
   * Dynatrace `apiUrl`, including the `/api` path at the end.
   * - For SaaS, set `YOUR_ENVIRONMENT_ID` to your environment ID.
   * - For Managed, change the `apiUrl` address.
   * For instructions on how to determine the environment ID and how to configure the apiUrl address, see Environment ID (https://www.
   *
   * @schema DynaKubeV1Beta2Spec#apiUrl
   */
  readonly apiUrl: string;

  /**
   * Defines a custom pull secret in case you use a private registry when pulling images from the Dynatrace environment.
   * To define a custom pull secret and learn about the expected behavior, see Configure customPullSecret
   * (https://www.dynatrace.
   *
   * @schema DynaKubeV1Beta2Spec#customPullSecret
   */
  readonly customPullSecret?: string;

  /**
   * Minimum minutes between Dynatrace API requests.
   *
   * @schema DynaKubeV1Beta2Spec#dynatraceApiRequestThreshold
   */
  readonly dynatraceApiRequestThreshold?: number;

  /**
   * When enabled, and if Istio is installed in the Kubernetes environment, Dynatrace Operator will create the corresponding VirtualService and ServiceEntry objects to allow access to the Dynatrace Cluster from the OneAgent or ActiveGate.
   * Disabled by default.
   *
   * @schema DynaKubeV1Beta2Spec#enableIstio
   */
  readonly enableIstio?: boolean;

  /**
   * Configuration for Metadata Enrichment.
   *
   * @schema DynaKubeV1Beta2Spec#metadataEnrichment
   */
  readonly metadataEnrichment?: DynaKubeV1Beta2SpecMetadataEnrichment;

  /**
   * Sets a network zone for the OneAgent and ActiveGate pods.
   *
   * @schema DynaKubeV1Beta2Spec#networkZone
   */
  readonly networkZone?: string;

  /**
   * General configuration about OneAgent instances.
   * You can't enable more than one module (classicFullStack, cloudNativeFullStack, hostMonitoring, or applicationMonitoring).
   *
   * @schema DynaKubeV1Beta2Spec#oneAgent
   */
  readonly oneAgent?: DynaKubeV1Beta2SpecOneAgent;

  /**
   * Set custom proxy settings either directly or from a secret with the field `proxy`.
   * Applies to Dynatrace Operator, ActiveGate, and OneAgents.
   *
   * @schema DynaKubeV1Beta2Spec#proxy
   */
  readonly proxy?: DynaKubeV1Beta2SpecProxy;

  /**
   * Disable certificate check for the connection between Dynatrace Operator and the Dynatrace Cluster.
   * Set to `true` if you want to skip certification validation checks.
   *
   * @schema DynaKubeV1Beta2Spec#skipCertCheck
   */
  readonly skipCertCheck?: boolean;

  /**
   * Name of the secret holding the tokens used for connecting to Dynatrace.
   *
   * @schema DynaKubeV1Beta2Spec#tokens
   */
  readonly tokens?: string;

  /**
   * Adds custom RootCAs from a configmap.
   * The key to the data must be `certs`.
   * This applies to both the Dynatrace Operator and the OneAgent. Doesn't apply to ActiveGate.
   *
   * @schema DynaKubeV1Beta2Spec#trustedCAs
   */
  readonly trustedCAs?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2Spec' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2Spec(obj: DynaKubeV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'activeGate': toJson_DynaKubeV1Beta2SpecActiveGate(obj.activeGate),
    'apiUrl': obj.apiUrl,
    'customPullSecret': obj.customPullSecret,
    'dynatraceApiRequestThreshold': obj.dynatraceApiRequestThreshold,
    'enableIstio': obj.enableIstio,
    'metadataEnrichment': toJson_DynaKubeV1Beta2SpecMetadataEnrichment(obj.metadataEnrichment),
    'networkZone': obj.networkZone,
    'oneAgent': toJson_DynaKubeV1Beta2SpecOneAgent(obj.oneAgent),
    'proxy': toJson_DynaKubeV1Beta2SpecProxy(obj.proxy),
    'skipCertCheck': obj.skipCertCheck,
    'tokens': obj.tokens,
    'trustedCAs': obj.trustedCAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * General configuration about ActiveGate instances.
 *
 * @schema DynaKubeV1Beta2SpecActiveGate
 */
export interface DynaKubeV1Beta2SpecActiveGate {
  /**
   * Adds additional annotations to the ActiveGate pods
   *
   * @schema DynaKubeV1Beta2SpecActiveGate#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Defines the ActiveGate pod capabilities
   * Possible values:
   * - `routing` enables OneAgent routing.
   * - `kubernetes-monitoring` enables Kubernetes API monitoring.
   * - `metrics-ingest` opens the metrics ingest endpoint on the DynaKube ActiveGate and redirects all pods to it.
   *
   * @schema DynaKubeV1Beta2SpecActiveGate#capabilities
   */
  readonly capabilities?: string[];

  /**
   * Add a custom properties file by providing it as a value or reference it from a secret
   * If referenced from a secret, make sure the key is called `customProperties`
   *
   * @schema DynaKubeV1Beta2SpecActiveGate#customProperties
   */
  readonly customProperties?: DynaKubeV1Beta2SpecActiveGateCustomProperties;

  /**
   * Sets DNS Policy for the ActiveGate pods
   *
   * @schema DynaKubeV1Beta2SpecActiveGate#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * List of environment variables to set for the ActiveGate
   *
   * @schema DynaKubeV1Beta2SpecActiveGate#env
   */
  readonly env?: DynaKubeV1Beta2SpecActiveGateEnv[];

  /**
   * Set activation group for ActiveGate
   *
   * @schema DynaKubeV1Beta2SpecActiveGate#group
   */
  readonly group?: string;

  /**
   * Use a custom ActiveGate image. Defaults to the latest ActiveGate image provided by the registry on the tenant
   *
   * @default the latest ActiveGate image provided by the registry on the tenant
   * @schema DynaKubeV1Beta2SpecActiveGate#image
   */
  readonly image?: string;

  /**
   * Your defined labels for ActiveGate pods in order to structure workloads as desired.
   *
   * @schema DynaKubeV1Beta2SpecActiveGate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Specify the node selector that controls on which nodes ActiveGate will be deployed.
   *
   * @schema DynaKubeV1Beta2SpecActiveGate#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Assign a priority class to the ActiveGate pods. By default, no class is set.
   * For details, see Pod Priority and Preemption. (https://dt-url.net/n8437bl)
   *
   * @schema DynaKubeV1Beta2SpecActiveGate#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Amount of replicas for your ActiveGates
   *
   * @schema DynaKubeV1Beta2SpecActiveGate#replicas
   */
  readonly replicas?: number;

  /**
   * Resource settings for ActiveGate container.
   * Consumption of the ActiveGate heavily depends on the workload to monitor. Adjust values accordingly.
   *
   * @schema DynaKubeV1Beta2SpecActiveGate#resources
   */
  readonly resources?: DynaKubeV1Beta2SpecActiveGateResources;

  /**
   * The name of a secret containing ActiveGate TLS cert+key and password. If not set, self-signed certificate is used.
   * `server.p12`: certificate+key pair in pkcs12 format
   * `password`: passphrase to read server.p12
   *
   * @schema DynaKubeV1Beta2SpecActiveGate#tlsSecretName
   */
  readonly tlsSecretName?: string;

  /**
   * Set tolerations for the ActiveGate pods
   *
   * @schema DynaKubeV1Beta2SpecActiveGate#tolerations
   */
  readonly tolerations?: DynaKubeV1Beta2SpecActiveGateTolerations[];

  /**
   * Adds TopologySpreadConstraints to the ActiveGate pods
   *
   * @schema DynaKubeV1Beta2SpecActiveGate#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecActiveGate' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecActiveGate(obj: DynaKubeV1Beta2SpecActiveGate | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'capabilities': obj.capabilities?.map(y => y),
    'customProperties': toJson_DynaKubeV1Beta2SpecActiveGateCustomProperties(obj.customProperties),
    'dnsPolicy': obj.dnsPolicy,
    'env': obj.env?.map(y => toJson_DynaKubeV1Beta2SpecActiveGateEnv(y)),
    'group': obj.group,
    'image': obj.image,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'priorityClassName': obj.priorityClassName,
    'replicas': obj.replicas,
    'resources': toJson_DynaKubeV1Beta2SpecActiveGateResources(obj.resources),
    'tlsSecretName': obj.tlsSecretName,
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeV1Beta2SpecActiveGateTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configuration for Metadata Enrichment.
 *
 * @schema DynaKubeV1Beta2SpecMetadataEnrichment
 */
export interface DynaKubeV1Beta2SpecMetadataEnrichment {
  /**
   * Enables MetadataEnrichment, `false` by default.
   *
   * @schema DynaKubeV1Beta2SpecMetadataEnrichment#enabled
   */
  readonly enabled: boolean;

  /**
   * The namespaces where you want Dynatrace Operator to inject enrichment.
   *
   * @schema DynaKubeV1Beta2SpecMetadataEnrichment#namespaceSelector
   */
  readonly namespaceSelector?: DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelector;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecMetadataEnrichment' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecMetadataEnrichment(obj: DynaKubeV1Beta2SpecMetadataEnrichment | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'enabled': obj.enabled,
    'namespaceSelector': toJson_DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelector(obj.namespaceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * General configuration about OneAgent instances.
 * You can't enable more than one module (classicFullStack, cloudNativeFullStack, hostMonitoring, or applicationMonitoring).
 *
 * @schema DynaKubeV1Beta2SpecOneAgent
 */
export interface DynaKubeV1Beta2SpecOneAgent {
  /**
   * dynatrace-webhook injects into application pods based on labeled namespaces.
   * Has an optional CSI driver per node via DaemonSet to provide binaries to pods.
   *
   * @schema DynaKubeV1Beta2SpecOneAgent#applicationMonitoring
   */
  readonly applicationMonitoring?: DynaKubeV1Beta2SpecOneAgentApplicationMonitoring;

  /**
   * Has a single OneAgent per node via DaemonSet.
   * Injection is performed via the same OneAgent DaemonSet.
   *
   * @schema DynaKubeV1Beta2SpecOneAgent#classicFullStack
   */
  readonly classicFullStack?: DynaKubeV1Beta2SpecOneAgentClassicFullStack;

  /**
   * Has a single OneAgent per node via DaemonSet.
   * dynatrace-webhook injects into application pods based on labeled namespaces.
   * Has a CSI driver per node via DaemonSet to provide binaries to pods.
   *
   * @schema DynaKubeV1Beta2SpecOneAgent#cloudNativeFullStack
   */
  readonly cloudNativeFullStack?: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack;

  /**
   * Specify the name of the group to which you want to assign the host.
   * This method is preferred over the now obsolete `--set-host-group` argument.
   * If both settings are used, this field takes precedence over the `--set-host-group` argument.
   *
   * @schema DynaKubeV1Beta2SpecOneAgent#hostGroup
   */
  readonly hostGroup?: string;

  /**
   * Has a single OneAgent per node via DaemonSet.
   * Doesn't inject into application pods.
   *
   * @schema DynaKubeV1Beta2SpecOneAgent#hostMonitoring
   */
  readonly hostMonitoring?: DynaKubeV1Beta2SpecOneAgentHostMonitoring;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgent' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgent(obj: DynaKubeV1Beta2SpecOneAgent | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'applicationMonitoring': toJson_DynaKubeV1Beta2SpecOneAgentApplicationMonitoring(obj.applicationMonitoring),
    'classicFullStack': toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStack(obj.classicFullStack),
    'cloudNativeFullStack': toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack(obj.cloudNativeFullStack),
    'hostGroup': obj.hostGroup,
    'hostMonitoring': toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoring(obj.hostMonitoring),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Set custom proxy settings either directly or from a secret with the field `proxy`.
 * Applies to Dynatrace Operator, ActiveGate, and OneAgents.
 *
 * @schema DynaKubeV1Beta2SpecProxy
 */
export interface DynaKubeV1Beta2SpecProxy {
  /**
   * Proxy URL. It has preference over ValueFrom.
   *
   * @schema DynaKubeV1Beta2SpecProxy#value
   */
  readonly value?: string;

  /**
   * Secret containing proxy URL.
   *
   * @schema DynaKubeV1Beta2SpecProxy#valueFrom
   */
  readonly valueFrom?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecProxy' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecProxy(obj: DynaKubeV1Beta2SpecProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'value': obj.value,
    'valueFrom': obj.valueFrom,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Add a custom properties file by providing it as a value or reference it from a secret
 * If referenced from a secret, make sure the key is called `customProperties`
 *
 * @schema DynaKubeV1Beta2SpecActiveGateCustomProperties
 */
export interface DynaKubeV1Beta2SpecActiveGateCustomProperties {
  /**
   * Custom properties value.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateCustomProperties#value
   */
  readonly value?: string;

  /**
   * Custom properties secret.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateCustomProperties#valueFrom
   */
  readonly valueFrom?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecActiveGateCustomProperties' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecActiveGateCustomProperties(obj: DynaKubeV1Beta2SpecActiveGateCustomProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'value': obj.value,
    'valueFrom': obj.valueFrom,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DynaKubeV1Beta2SpecActiveGateEnv
 */
export interface DynaKubeV1Beta2SpecActiveGateEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnv#valueFrom
   */
  readonly valueFrom?: DynaKubeV1Beta2SpecActiveGateEnvValueFrom;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecActiveGateEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecActiveGateEnv(obj: DynaKubeV1Beta2SpecActiveGateEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DynaKubeV1Beta2SpecActiveGateEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Resource settings for ActiveGate container.
 * Consumption of the ActiveGate heavily depends on the workload to monitor. Adjust values accordingly.
 *
 * @schema DynaKubeV1Beta2SpecActiveGateResources
 */
export interface DynaKubeV1Beta2SpecActiveGateResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateResources#claims
   */
  readonly claims?: DynaKubeV1Beta2SpecActiveGateResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeV1Beta2SpecActiveGateResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeV1Beta2SpecActiveGateResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeV1Beta2SpecActiveGateResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecActiveGateResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecActiveGateResources(obj: DynaKubeV1Beta2SpecActiveGateResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeV1Beta2SpecActiveGateResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeV1Beta2SpecActiveGateTolerations
 */
export interface DynaKubeV1Beta2SpecActiveGateTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeV1Beta2SpecActiveGateTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeV1Beta2SpecActiveGateTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecActiveGateTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecActiveGateTolerations(obj: DynaKubeV1Beta2SpecActiveGateTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraints
 */
export interface DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraints' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraints(obj: DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'labelSelector': toJson_DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The namespaces where you want Dynatrace Operator to inject enrichment.
 *
 * @schema DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelector
 */
export interface DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelector(obj: DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * dynatrace-webhook injects into application pods based on labeled namespaces.
 * Has an optional CSI driver per node via DaemonSet to provide binaries to pods.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoring
 */
export interface DynaKubeV1Beta2SpecOneAgentApplicationMonitoring {
  /**
   * The OneAgent image that is used to inject into Pods.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoring#codeModulesImage
   */
  readonly codeModulesImage?: string;

  /**
   * Define resources requests and limits for the initContainer. For details, see Managing resources for containers
   * (https://kubernetes.io/docs/concepts/configuration/manage-resources-containers).
   *
   * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoring#initResources
   */
  readonly initResources?: DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResources;

  /**
   * Applicable only for applicationMonitoring or cloudNativeFullStack configuration types. The namespaces where you want Dynatrace Operator to inject.
   * For more information, see Configure monitoring for namespaces and pods (https://www.dynatrace.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoring#namespaceSelector
   */
  readonly namespaceSelector?: DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelector;

  /**
   * Set if you want to use the CSIDriver. Don't enable it if you do not have access to Kubernetes nodes or if you lack privileges.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoring#useCSIDriver
   */
  readonly useCsiDriver?: boolean;

  /**
   * The OneAgent version to be used.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoring#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentApplicationMonitoring' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentApplicationMonitoring(obj: DynaKubeV1Beta2SpecOneAgentApplicationMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'codeModulesImage': obj.codeModulesImage,
    'initResources': toJson_DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResources(obj.initResources),
    'namespaceSelector': toJson_DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelector(obj.namespaceSelector),
    'useCSIDriver': obj.useCsiDriver,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Has a single OneAgent per node via DaemonSet.
 * Injection is performed via the same OneAgent DaemonSet.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStack
 */
export interface DynaKubeV1Beta2SpecOneAgentClassicFullStack {
  /**
   * Add custom OneAgent annotations.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStack#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Set additional arguments to the OneAgent installer.
   * For available options, see Linux custom installation (https://www.dynatrace.com/support/help/setup-and-configuration/dynatrace-oneagent/installation-and-operation/linux/installation/customize-oneagent-installation-on-linux).
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStack#args
   */
  readonly args?: string[];

  /**
   * Disables automatic restarts of OneAgent pods in case a new version is available (https://www.dynatrace.com/support/help/setup-and-configuration/setup-on-container-platforms/kubernetes/get-started-with-kubernetes-monitoring#disable-auto).
   * Enabled by default.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStack#autoUpdate
   */
  readonly autoUpdate?: boolean;

  /**
   * Set the DNS Policy for OneAgent pods. For details, see Pods DNS Policy (https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy).
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStack#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * Set additional environment variables for the OneAgent pods.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStack#env
   */
  readonly env?: DynaKubeV1Beta2SpecOneAgentClassicFullStackEnv[];

  /**
   * Use a custom OneAgent Docker image. Defaults to the image from the Dynatrace cluster.
   *
   * @default the image from the Dynatrace cluster.
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStack#image
   */
  readonly image?: string;

  /**
   * Your defined labels for OneAgent pods in order to structure workloads as desired.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStack#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Specify the node selector that controls on which nodes OneAgent will be deployed.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStack#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
   * - `resource.requests` shows the values needed to run
   * - `resource.limits` shows the maximum limits for the pod
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStack#oneAgentResources
   */
  readonly oneAgentResources?: DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResources;

  /**
   * Assign a priority class to the OneAgent pods. By default, no class is set.
   * For details, see Pod Priority and Preemption (https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/).
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStack#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The SecComp Profile that will be configured in order to run in secure computing mode.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStack#secCompProfile
   */
  readonly secCompProfile?: string;

  /**
   * Tolerations to include with the OneAgent DaemonSet. For details, see Taints and Tolerations (https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/).
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStack#tolerations
   */
  readonly tolerations?: DynaKubeV1Beta2SpecOneAgentClassicFullStackTolerations[];

  /**
   * The OneAgent version to be used for OneAgents running in the dedicated pod. This setting doesn't affect the OneAgent version used for application monitoring.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStack#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentClassicFullStack' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStack(obj: DynaKubeV1Beta2SpecOneAgentClassicFullStack | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'args': obj.args?.map(y => y),
    'autoUpdate': obj.autoUpdate,
    'dnsPolicy': obj.dnsPolicy,
    'env': obj.env?.map(y => toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackEnv(y)),
    'image': obj.image,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'oneAgentResources': toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResources(obj.oneAgentResources),
    'priorityClassName': obj.priorityClassName,
    'secCompProfile': obj.secCompProfile,
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackTolerations(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Has a single OneAgent per node via DaemonSet.
 * dynatrace-webhook injects into application pods based on labeled namespaces.
 * Has a CSI driver per node via DaemonSet to provide binaries to pods.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack
 */
export interface DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack {
  /**
   * Add custom OneAgent annotations.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Set additional arguments to the OneAgent installer.
   * For available options, see Linux custom installation (https://www.dynatrace.com/support/help/setup-and-configuration/dynatrace-oneagent/installation-and-operation/linux/installation/customize-oneagent-installation-on-linux).
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack#args
   */
  readonly args?: string[];

  /**
   * Disables automatic restarts of OneAgent pods in case a new version is available (https://www.dynatrace.com/support/help/setup-and-configuration/setup-on-container-platforms/kubernetes/get-started-with-kubernetes-monitoring#disable-auto).
   * Enabled by default.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack#autoUpdate
   */
  readonly autoUpdate?: boolean;

  /**
   * The OneAgent image that is used to inject into Pods.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack#codeModulesImage
   */
  readonly codeModulesImage?: string;

  /**
   * Set the DNS Policy for OneAgent pods. For details, see Pods DNS Policy (https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy).
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * Set additional environment variables for the OneAgent pods.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack#env
   */
  readonly env?: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnv[];

  /**
   * Use a custom OneAgent Docker image. Defaults to the image from the Dynatrace cluster.
   *
   * @default the image from the Dynatrace cluster.
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack#image
   */
  readonly image?: string;

  /**
   * Define resources requests and limits for the initContainer. For details, see Managing resources for containers
   * (https://kubernetes.io/docs/concepts/configuration/manage-resources-containers).
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack#initResources
   */
  readonly initResources?: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResources;

  /**
   * Your defined labels for OneAgent pods in order to structure workloads as desired.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Applicable only for applicationMonitoring or cloudNativeFullStack configuration types. The namespaces where you want Dynatrace Operator to inject.
   * For more information, see Configure monitoring for namespaces and pods (https://www.dynatrace.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack#namespaceSelector
   */
  readonly namespaceSelector?: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelector;

  /**
   * Specify the node selector that controls on which nodes OneAgent will be deployed.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
   * - `resource.requests` shows the values needed to run
   * - `resource.limits` shows the maximum limits for the pod
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack#oneAgentResources
   */
  readonly oneAgentResources?: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResources;

  /**
   * Assign a priority class to the OneAgent pods. By default, no class is set.
   * For details, see Pod Priority and Preemption (https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/).
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The SecComp Profile that will be configured in order to run in secure computing mode.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack#secCompProfile
   */
  readonly secCompProfile?: string;

  /**
   * Tolerations to include with the OneAgent DaemonSet. For details, see Taints and Tolerations (https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/).
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack#tolerations
   */
  readonly tolerations?: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackTolerations[];

  /**
   * The OneAgent version to be used for OneAgents running in the dedicated pod. This setting doesn't affect the OneAgent version used for application monitoring.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack(obj: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStack | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'args': obj.args?.map(y => y),
    'autoUpdate': obj.autoUpdate,
    'codeModulesImage': obj.codeModulesImage,
    'dnsPolicy': obj.dnsPolicy,
    'env': obj.env?.map(y => toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnv(y)),
    'image': obj.image,
    'initResources': toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResources(obj.initResources),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'namespaceSelector': toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelector(obj.namespaceSelector),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'oneAgentResources': toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResources(obj.oneAgentResources),
    'priorityClassName': obj.priorityClassName,
    'secCompProfile': obj.secCompProfile,
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackTolerations(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Has a single OneAgent per node via DaemonSet.
 * Doesn't inject into application pods.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoring
 */
export interface DynaKubeV1Beta2SpecOneAgentHostMonitoring {
  /**
   * Add custom OneAgent annotations.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoring#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Set additional arguments to the OneAgent installer.
   * For available options, see Linux custom installation (https://www.dynatrace.com/support/help/setup-and-configuration/dynatrace-oneagent/installation-and-operation/linux/installation/customize-oneagent-installation-on-linux).
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoring#args
   */
  readonly args?: string[];

  /**
   * Disables automatic restarts of OneAgent pods in case a new version is available (https://www.dynatrace.com/support/help/setup-and-configuration/setup-on-container-platforms/kubernetes/get-started-with-kubernetes-monitoring#disable-auto).
   * Enabled by default.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoring#autoUpdate
   */
  readonly autoUpdate?: boolean;

  /**
   * Set the DNS Policy for OneAgent pods. For details, see Pods DNS Policy (https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy).
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoring#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * Set additional environment variables for the OneAgent pods.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoring#env
   */
  readonly env?: DynaKubeV1Beta2SpecOneAgentHostMonitoringEnv[];

  /**
   * Use a custom OneAgent Docker image. Defaults to the image from the Dynatrace cluster.
   *
   * @default the image from the Dynatrace cluster.
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoring#image
   */
  readonly image?: string;

  /**
   * Your defined labels for OneAgent pods in order to structure workloads as desired.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoring#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Specify the node selector that controls on which nodes OneAgent will be deployed.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoring#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
   * - `resource.requests` shows the values needed to run
   * - `resource.limits` shows the maximum limits for the pod
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoring#oneAgentResources
   */
  readonly oneAgentResources?: DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResources;

  /**
   * Assign a priority class to the OneAgent pods. By default, no class is set.
   * For details, see Pod Priority and Preemption (https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/).
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoring#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The SecComp Profile that will be configured in order to run in secure computing mode.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoring#secCompProfile
   */
  readonly secCompProfile?: string;

  /**
   * Tolerations to include with the OneAgent DaemonSet. For details, see Taints and Tolerations (https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/).
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoring#tolerations
   */
  readonly tolerations?: DynaKubeV1Beta2SpecOneAgentHostMonitoringTolerations[];

  /**
   * The OneAgent version to be used for OneAgents running in the dedicated pod. This setting doesn't affect the OneAgent version used for application monitoring.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoring#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentHostMonitoring' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoring(obj: DynaKubeV1Beta2SpecOneAgentHostMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'args': obj.args?.map(y => y),
    'autoUpdate': obj.autoUpdate,
    'dnsPolicy': obj.dnsPolicy,
    'env': obj.env?.map(y => toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringEnv(y)),
    'image': obj.image,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'oneAgentResources': toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResources(obj.oneAgentResources),
    'priorityClassName': obj.priorityClassName,
    'secCompProfile': obj.secCompProfile,
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringTolerations(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFrom
 */
export interface DynaKubeV1Beta2SpecActiveGateEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DynaKubeV1Beta2SpecActiveGateEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DynaKubeV1Beta2SpecActiveGateEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DynaKubeV1Beta2SpecActiveGateEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DynaKubeV1Beta2SpecActiveGateEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecActiveGateEnvValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecActiveGateEnvValueFrom(obj: DynaKubeV1Beta2SpecActiveGateEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'configMapKeyRef': toJson_DynaKubeV1Beta2SpecActiveGateEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DynaKubeV1Beta2SpecActiveGateEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DynaKubeV1Beta2SpecActiveGateEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DynaKubeV1Beta2SpecActiveGateEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeV1Beta2SpecActiveGateResourcesClaims
 */
export interface DynaKubeV1Beta2SpecActiveGateResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecActiveGateResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecActiveGateResourcesClaims(obj: DynaKubeV1Beta2SpecActiveGateResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta2SpecActiveGateResourcesLimits
 */
export class DynaKubeV1Beta2SpecActiveGateResourcesLimits {
  public static fromNumber(value: number): DynaKubeV1Beta2SpecActiveGateResourcesLimits {
    return new DynaKubeV1Beta2SpecActiveGateResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeV1Beta2SpecActiveGateResourcesLimits {
    return new DynaKubeV1Beta2SpecActiveGateResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeV1Beta2SpecActiveGateResourcesRequests
 */
export class DynaKubeV1Beta2SpecActiveGateResourcesRequests {
  public static fromNumber(value: number): DynaKubeV1Beta2SpecActiveGateResourcesRequests {
    return new DynaKubeV1Beta2SpecActiveGateResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeV1Beta2SpecActiveGateResourcesRequests {
    return new DynaKubeV1Beta2SpecActiveGateResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelector
 */
export interface DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelector(obj: DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelectorMatchExpressions
 */
export interface DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelectorMatchExpressions(obj: DynaKubeV1Beta2SpecMetadataEnrichmentNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Define resources requests and limits for the initContainer. For details, see Managing resources for containers
 * (https://kubernetes.io/docs/concepts/configuration/manage-resources-containers).
 *
 * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResources
 */
export interface DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResources#claims
   */
  readonly claims?: DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResources(obj: DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Applicable only for applicationMonitoring or cloudNativeFullStack configuration types. The namespaces where you want Dynatrace Operator to inject.
 * For more information, see Configure monitoring for namespaces and pods (https://www.dynatrace.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelector
 */
export interface DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelector(obj: DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnv
 */
export interface DynaKubeV1Beta2SpecOneAgentClassicFullStackEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnv#valueFrom
   */
  readonly valueFrom?: DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFrom;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentClassicFullStackEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackEnv(obj: DynaKubeV1Beta2SpecOneAgentClassicFullStackEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
 * - `resource.requests` shows the values needed to run
 * - `resource.limits` shows the maximum limits for the pod
 *
 * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResources
 */
export interface DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResources#claims
   */
  readonly claims?: DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResources(obj: DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackTolerations
 */
export interface DynaKubeV1Beta2SpecOneAgentClassicFullStackTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentClassicFullStackTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackTolerations(obj: DynaKubeV1Beta2SpecOneAgentClassicFullStackTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnv
 */
export interface DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnv#valueFrom
   */
  readonly valueFrom?: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFrom;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnv(obj: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Define resources requests and limits for the initContainer. For details, see Managing resources for containers
 * (https://kubernetes.io/docs/concepts/configuration/manage-resources-containers).
 *
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResources
 */
export interface DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResources#claims
   */
  readonly claims?: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResources(obj: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Applicable only for applicationMonitoring or cloudNativeFullStack configuration types. The namespaces where you want Dynatrace Operator to inject.
 * For more information, see Configure monitoring for namespaces and pods (https://www.dynatrace.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelector
 */
export interface DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelector(obj: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
 * - `resource.requests` shows the values needed to run
 * - `resource.limits` shows the maximum limits for the pod
 *
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResources
 */
export interface DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResources#claims
   */
  readonly claims?: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResources(obj: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackTolerations
 */
export interface DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackTolerations(obj: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnv
 */
export interface DynaKubeV1Beta2SpecOneAgentHostMonitoringEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnv#valueFrom
   */
  readonly valueFrom?: DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFrom;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentHostMonitoringEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringEnv(obj: DynaKubeV1Beta2SpecOneAgentHostMonitoringEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
 * - `resource.requests` shows the values needed to run
 * - `resource.limits` shows the maximum limits for the pod
 *
 * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResources
 */
export interface DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResources#claims
   */
  readonly claims?: DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResources(obj: DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringTolerations
 */
export interface DynaKubeV1Beta2SpecOneAgentHostMonitoringTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentHostMonitoringTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringTolerations(obj: DynaKubeV1Beta2SpecOneAgentHostMonitoringTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFromConfigMapKeyRef
 */
export interface DynaKubeV1Beta2SpecActiveGateEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecActiveGateEnvValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecActiveGateEnvValueFromConfigMapKeyRef(obj: DynaKubeV1Beta2SpecActiveGateEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFromFieldRef
 */
export interface DynaKubeV1Beta2SpecActiveGateEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecActiveGateEnvValueFromFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecActiveGateEnvValueFromFieldRef(obj: DynaKubeV1Beta2SpecActiveGateEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFromResourceFieldRef
 */
export interface DynaKubeV1Beta2SpecActiveGateEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DynaKubeV1Beta2SpecActiveGateEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecActiveGateEnvValueFromResourceFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecActiveGateEnvValueFromResourceFieldRef(obj: DynaKubeV1Beta2SpecActiveGateEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFromSecretKeyRef
 */
export interface DynaKubeV1Beta2SpecActiveGateEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecActiveGateEnvValueFromSecretKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecActiveGateEnvValueFromSecretKeyRef(obj: DynaKubeV1Beta2SpecActiveGateEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: DynaKubeV1Beta2SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesClaims
 */
export interface DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesClaims(obj: DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesLimits
 */
export class DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesLimits {
  public static fromNumber(value: number): DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesLimits {
    return new DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesLimits {
    return new DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesRequests
 */
export class DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesRequests {
  public static fromNumber(value: number): DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesRequests {
    return new DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesRequests {
    return new DynaKubeV1Beta2SpecOneAgentApplicationMonitoringInitResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions
 */
export interface DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions(obj: DynaKubeV1Beta2SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFrom
 */
export interface DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFrom(obj: DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'configMapKeyRef': toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesClaims
 */
export interface DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesClaims(obj: DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesLimits
 */
export class DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesLimits {
  public static fromNumber(value: number): DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesLimits {
    return new DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesLimits {
    return new DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesRequests
 */
export class DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesRequests {
  public static fromNumber(value: number): DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesRequests {
    return new DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesRequests {
    return new DynaKubeV1Beta2SpecOneAgentClassicFullStackOneAgentResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFrom
 */
export interface DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFrom(obj: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'configMapKeyRef': toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesClaims
 */
export interface DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesClaims(obj: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesLimits
 */
export class DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesLimits {
  public static fromNumber(value: number): DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesLimits {
    return new DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesLimits {
    return new DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesRequests
 */
export class DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesRequests {
  public static fromNumber(value: number): DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesRequests {
    return new DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesRequests {
    return new DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackInitResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions
 */
export interface DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions(obj: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims
 */
export interface DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims(obj: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesLimits
 */
export class DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesLimits {
  public static fromNumber(value: number): DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesLimits {
    return new DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesLimits {
    return new DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesRequests
 */
export class DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesRequests {
  public static fromNumber(value: number): DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesRequests {
    return new DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesRequests {
    return new DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackOneAgentResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFrom
 */
export interface DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFrom(obj: DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'configMapKeyRef': toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesClaims
 */
export interface DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesClaims(obj: DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesLimits
 */
export class DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesLimits {
  public static fromNumber(value: number): DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesLimits {
    return new DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesLimits {
    return new DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesRequests
 */
export class DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesRequests {
  public static fromNumber(value: number): DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesRequests {
    return new DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesRequests {
    return new DynaKubeV1Beta2SpecOneAgentHostMonitoringOneAgentResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DynaKubeV1Beta2SpecActiveGateEnvValueFromResourceFieldRefDivisor
 */
export class DynaKubeV1Beta2SpecActiveGateEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DynaKubeV1Beta2SpecActiveGateEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta2SpecActiveGateEnvValueFromResourceFieldRefDivisor(value);
  }

  public static fromString(value: string): DynaKubeV1Beta2SpecActiveGateEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta2SpecActiveGateEnvValueFromResourceFieldRefDivisor(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef
 */
export interface DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef(obj: DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromFieldRef
 */
export interface DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromFieldRef(obj: DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef
 */
export interface DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef(obj: DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef
 */
export interface DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef(obj: DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef
 */
export interface DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef(obj: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef
 */
export interface DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef(obj: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef
 */
export interface DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef(obj: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef
 */
export interface DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef(obj: DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef
 */
export interface DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef(obj: DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromFieldRef
 */
export interface DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromFieldRef(obj: DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef
 */
export interface DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef(obj: DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef
 */
export interface DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef(obj: DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor
 */
export class DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor(value);
  }

  public static fromString(value: string): DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta2SpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor
 */
export class DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor(value);
  }

  public static fromString(value: string): DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta2SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor
 */
export class DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor(value);
  }

  public static fromString(value: string): DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta2SpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor(value);
  }

  private constructor(public readonly value: number | string) {
  }
}


/**
 * DynaKube is the Schema for the DynaKube API
 *
 * @schema DynaKubeV1Beta3
 */
export class DynaKubeV1Beta3 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DynaKubeV1Beta3"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dynatrace.com/v1beta3',
    kind: 'DynaKube',
  };

  /**
   * Renders a Kubernetes manifest for "DynaKubeV1Beta3".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DynaKubeV1Beta3Props = {}): any {
    return {
      ...DynaKubeV1Beta3.GVK,
      ...toJson_DynaKubeV1Beta3Props(props),
    };
  }

  /**
   * Defines a "DynaKubeV1Beta3" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DynaKubeV1Beta3Props = {}) {
    super(scope, id, {
      ...DynaKubeV1Beta3.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DynaKubeV1Beta3.GVK,
      ...toJson_DynaKubeV1Beta3Props(resolved),
    };
  }
}

/**
 * DynaKube is the Schema for the DynaKube API
 *
 * @schema DynaKubeV1Beta3
 */
export interface DynaKubeV1Beta3Props {
  /**
   * @schema DynaKubeV1Beta3#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DynaKubeSpec defines the desired state of DynaKube
   *
   * @schema DynaKubeV1Beta3#spec
   */
  readonly spec?: DynaKubeV1Beta3Spec;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3Props' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3Props(obj: DynaKubeV1Beta3Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DynaKubeV1Beta3Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * DynaKubeSpec defines the desired state of DynaKube
 *
 * @schema DynaKubeV1Beta3Spec
 */
export interface DynaKubeV1Beta3Spec {
  /**
   * General configuration about ActiveGate instances.
   *
   * @schema DynaKubeV1Beta3Spec#activeGate
   */
  readonly activeGate?: DynaKubeV1Beta3SpecActiveGate;

  /**
   * Dynatrace apiUrl, including the /api path at the end. For SaaS, set YOUR_ENVIRONMENT_ID to your environment ID. For Managed, change the apiUrl address.
   * For instructions on how to determine the environment ID and how to configure the apiUrl address, see Environment ID (https://www.dynatrace.
   *
   * @schema DynaKubeV1Beta3Spec#apiUrl
   */
  readonly apiUrl: string;

  /**
   * Defines a custom pull secret in case you use a private registry when pulling images from the Dynatrace environment.
   * To define a custom pull secret and learn about the expected behavior, see Configure customPullSecret
   * (https://www.dynatrace.
   *
   * @schema DynaKubeV1Beta3Spec#customPullSecret
   */
  readonly customPullSecret?: string;

  /**
   * Configuration for thresholding Dynatrace API requests.
   *
   * @schema DynaKubeV1Beta3Spec#dynatraceApiRequestThreshold
   */
  readonly dynatraceApiRequestThreshold?: number;

  /**
   * When enabled, and if Istio is installed on the Kubernetes environment, Dynatrace Operator will create the corresponding
   * VirtualService and ServiceEntry objects to allow access to the Dynatrace Cluster from the OneAgent or ActiveGate.
   * Disabled by default.
   *
   * @schema DynaKubeV1Beta3Spec#enableIstio
   */
  readonly enableIstio?: boolean;

  /**
   * When an (empty) ExtensionsSpec is provided, the extensions related components (extensions controller and extensions collector)
   * are deployed by the operator.
   *
   * @schema DynaKubeV1Beta3Spec#extensions
   */
  readonly extensions?: any;

  /**
   * General configuration about the KSPM feature.
   *
   * @schema DynaKubeV1Beta3Spec#kspm
   */
  readonly kspm?: any;

  /**
   * General configuration about the LogMonitoring feature.
   *
   * @schema DynaKubeV1Beta3Spec#logMonitoring
   */
  readonly logMonitoring?: DynaKubeV1Beta3SpecLogMonitoring;

  /**
   * Configuration for Metadata Enrichment.
   *
   * @schema DynaKubeV1Beta3Spec#metadataEnrichment
   */
  readonly metadataEnrichment?: DynaKubeV1Beta3SpecMetadataEnrichment;

  /**
   * Sets a network zone for the OneAgent and ActiveGate pods.
   *
   * @schema DynaKubeV1Beta3Spec#networkZone
   */
  readonly networkZone?: string;

  /**
   * General configuration about OneAgent instances.
   * You can't enable more than one module (classicFullStack, cloudNativeFullStack, hostMonitoring, or applicationMonitoring).
   *
   * @schema DynaKubeV1Beta3Spec#oneAgent
   */
  readonly oneAgent?: DynaKubeV1Beta3SpecOneAgent;

  /**
   * Set custom proxy settings either directly or from a secret with the field proxy.
   * Note: Applies to Dynatrace Operator, ActiveGate, and OneAgents.
   *
   * @schema DynaKubeV1Beta3Spec#proxy
   */
  readonly proxy?: DynaKubeV1Beta3SpecProxy;

  /**
   * Disable certificate check for the connection between Dynatrace Operator and the Dynatrace Cluster.
   * Set to true if you want to skip certification validation checks.
   *
   * @schema DynaKubeV1Beta3Spec#skipCertCheck
   */
  readonly skipCertCheck?: boolean;

  /**
   * @schema DynaKubeV1Beta3Spec#templates
   */
  readonly templates?: DynaKubeV1Beta3SpecTemplates;

  /**
   * Name of the secret holding the tokens used for connecting to Dynatrace.
   *
   * @schema DynaKubeV1Beta3Spec#tokens
   */
  readonly tokens?: string;

  /**
   * Adds custom RootCAs from a configmap. Put the certificate under certs within your configmap.
   * Note: Applies to Dynatrace Operator, OneAgent and ActiveGate.
   *
   * @schema DynaKubeV1Beta3Spec#trustedCAs
   */
  readonly trustedCAs?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3Spec' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3Spec(obj: DynaKubeV1Beta3Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'activeGate': toJson_DynaKubeV1Beta3SpecActiveGate(obj.activeGate),
    'apiUrl': obj.apiUrl,
    'customPullSecret': obj.customPullSecret,
    'dynatraceApiRequestThreshold': obj.dynatraceApiRequestThreshold,
    'enableIstio': obj.enableIstio,
    'extensions': obj.extensions,
    'kspm': obj.kspm,
    'logMonitoring': toJson_DynaKubeV1Beta3SpecLogMonitoring(obj.logMonitoring),
    'metadataEnrichment': toJson_DynaKubeV1Beta3SpecMetadataEnrichment(obj.metadataEnrichment),
    'networkZone': obj.networkZone,
    'oneAgent': toJson_DynaKubeV1Beta3SpecOneAgent(obj.oneAgent),
    'proxy': toJson_DynaKubeV1Beta3SpecProxy(obj.proxy),
    'skipCertCheck': obj.skipCertCheck,
    'templates': toJson_DynaKubeV1Beta3SpecTemplates(obj.templates),
    'tokens': obj.tokens,
    'trustedCAs': obj.trustedCAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * General configuration about ActiveGate instances.
 *
 * @schema DynaKubeV1Beta3SpecActiveGate
 */
export interface DynaKubeV1Beta3SpecActiveGate {
  /**
   * Adds additional annotations to the ActiveGate pods
   *
   * @schema DynaKubeV1Beta3SpecActiveGate#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Activegate capabilities enabled (routing, kubernetes-monitoring, metrics-ingest, dynatrace-api)
   *
   * @schema DynaKubeV1Beta3SpecActiveGate#capabilities
   */
  readonly capabilities?: string[];

  /**
   * Add a custom properties file by providing it as a value or reference it from a secret
   * If referenced from a secret, make sure the key is called 'customProperties'
   *
   * @schema DynaKubeV1Beta3SpecActiveGate#customProperties
   */
  readonly customProperties?: DynaKubeV1Beta3SpecActiveGateCustomProperties;

  /**
   * Sets DNS Policy for the ActiveGate pods
   *
   * @schema DynaKubeV1Beta3SpecActiveGate#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * List of environment variables to set for the ActiveGate
   *
   * @schema DynaKubeV1Beta3SpecActiveGate#env
   */
  readonly env?: DynaKubeV1Beta3SpecActiveGateEnv[];

  /**
   * Set activation group for ActiveGate
   *
   * @schema DynaKubeV1Beta3SpecActiveGate#group
   */
  readonly group?: string;

  /**
   * The ActiveGate container image. Defaults to the latest ActiveGate image provided by the registry on the tenant
   *
   * @default the latest ActiveGate image provided by the registry on the tenant
   * @schema DynaKubeV1Beta3SpecActiveGate#image
   */
  readonly image?: string;

  /**
   * Adds additional labels for the ActiveGate pods
   *
   * @schema DynaKubeV1Beta3SpecActiveGate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Node selector to control the selection of nodes
   *
   * @schema DynaKubeV1Beta3SpecActiveGate#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * If specified, indicates the pod's priority. Name must be defined by creating a PriorityClass object with that
   * name. If not specified the setting will be removed from the StatefulSet.
   *
   * @schema DynaKubeV1Beta3SpecActiveGate#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Amount of replicas for your ActiveGates
   *
   * @schema DynaKubeV1Beta3SpecActiveGate#replicas
   */
  readonly replicas?: number;

  /**
   * Define resources requests and limits for single ActiveGate pods
   *
   * @schema DynaKubeV1Beta3SpecActiveGate#resources
   */
  readonly resources?: DynaKubeV1Beta3SpecActiveGateResources;

  /**
   * The name of a secret containing ActiveGate TLS cert+key and password. If not set, self-signed certificate is used.
   * server.p12: certificate+key pair in pkcs12 format
   * password: passphrase to read server.p12
   *
   * @schema DynaKubeV1Beta3SpecActiveGate#tlsSecretName
   */
  readonly tlsSecretName?: string;

  /**
   * Set tolerations for the ActiveGate pods
   *
   * @schema DynaKubeV1Beta3SpecActiveGate#tolerations
   */
  readonly tolerations?: DynaKubeV1Beta3SpecActiveGateTolerations[];

  /**
   * Adds TopologySpreadConstraints for the ActiveGate pods
   *
   * @schema DynaKubeV1Beta3SpecActiveGate#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecActiveGate' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecActiveGate(obj: DynaKubeV1Beta3SpecActiveGate | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'capabilities': obj.capabilities?.map(y => y),
    'customProperties': toJson_DynaKubeV1Beta3SpecActiveGateCustomProperties(obj.customProperties),
    'dnsPolicy': obj.dnsPolicy,
    'env': obj.env?.map(y => toJson_DynaKubeV1Beta3SpecActiveGateEnv(y)),
    'group': obj.group,
    'image': obj.image,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'priorityClassName': obj.priorityClassName,
    'replicas': obj.replicas,
    'resources': toJson_DynaKubeV1Beta3SpecActiveGateResources(obj.resources),
    'tlsSecretName': obj.tlsSecretName,
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeV1Beta3SpecActiveGateTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * General configuration about the LogMonitoring feature.
 *
 * @schema DynaKubeV1Beta3SpecLogMonitoring
 */
export interface DynaKubeV1Beta3SpecLogMonitoring {
  /**
   * @schema DynaKubeV1Beta3SpecLogMonitoring#ingestRuleMatchers
   */
  readonly ingestRuleMatchers?: DynaKubeV1Beta3SpecLogMonitoringIngestRuleMatchers[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecLogMonitoring' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecLogMonitoring(obj: DynaKubeV1Beta3SpecLogMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'ingestRuleMatchers': obj.ingestRuleMatchers?.map(y => toJson_DynaKubeV1Beta3SpecLogMonitoringIngestRuleMatchers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configuration for Metadata Enrichment.
 *
 * @schema DynaKubeV1Beta3SpecMetadataEnrichment
 */
export interface DynaKubeV1Beta3SpecMetadataEnrichment {
  /**
   * Enables MetadataEnrichment, `false` by default.
   *
   * @schema DynaKubeV1Beta3SpecMetadataEnrichment#enabled
   */
  readonly enabled?: boolean;

  /**
   * The namespaces where you want Dynatrace Operator to inject enrichment.
   *
   * @schema DynaKubeV1Beta3SpecMetadataEnrichment#namespaceSelector
   */
  readonly namespaceSelector?: DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelector;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecMetadataEnrichment' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecMetadataEnrichment(obj: DynaKubeV1Beta3SpecMetadataEnrichment | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'enabled': obj.enabled,
    'namespaceSelector': toJson_DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelector(obj.namespaceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * General configuration about OneAgent instances.
 * You can't enable more than one module (classicFullStack, cloudNativeFullStack, hostMonitoring, or applicationMonitoring).
 *
 * @schema DynaKubeV1Beta3SpecOneAgent
 */
export interface DynaKubeV1Beta3SpecOneAgent {
  /**
   * dynatrace-webhook injects into application pods based on labeled namespaces.
   * Has an optional CSI driver per node via DaemonSet to provide binaries to pods.
   *
   * @schema DynaKubeV1Beta3SpecOneAgent#applicationMonitoring
   */
  readonly applicationMonitoring?: DynaKubeV1Beta3SpecOneAgentApplicationMonitoring;

  /**
   * Has a single OneAgent per node via DaemonSet.
   * Injection is performed via the same OneAgent DaemonSet.
   *
   * @schema DynaKubeV1Beta3SpecOneAgent#classicFullStack
   */
  readonly classicFullStack?: DynaKubeV1Beta3SpecOneAgentClassicFullStack;

  /**
   * Has a single OneAgent per node via DaemonSet.
   * dynatrace-webhook injects into application pods based on labeled namespaces.
   * Has a CSI driver per node via DaemonSet to provide binaries to pods.
   *
   * @schema DynaKubeV1Beta3SpecOneAgent#cloudNativeFullStack
   */
  readonly cloudNativeFullStack?: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack;

  /**
   * Sets a host group for OneAgent.
   *
   * @schema DynaKubeV1Beta3SpecOneAgent#hostGroup
   */
  readonly hostGroup?: string;

  /**
   * Has a single OneAgent per node via DaemonSet.
   * Doesn't inject into application pods.
   *
   * @schema DynaKubeV1Beta3SpecOneAgent#hostMonitoring
   */
  readonly hostMonitoring?: DynaKubeV1Beta3SpecOneAgentHostMonitoring;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgent' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgent(obj: DynaKubeV1Beta3SpecOneAgent | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'applicationMonitoring': toJson_DynaKubeV1Beta3SpecOneAgentApplicationMonitoring(obj.applicationMonitoring),
    'classicFullStack': toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStack(obj.classicFullStack),
    'cloudNativeFullStack': toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack(obj.cloudNativeFullStack),
    'hostGroup': obj.hostGroup,
    'hostMonitoring': toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoring(obj.hostMonitoring),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Set custom proxy settings either directly or from a secret with the field proxy.
 * Note: Applies to Dynatrace Operator, ActiveGate, and OneAgents.
 *
 * @schema DynaKubeV1Beta3SpecProxy
 */
export interface DynaKubeV1Beta3SpecProxy {
  /**
   * Raw value for given property.
   *
   * @schema DynaKubeV1Beta3SpecProxy#value
   */
  readonly value?: string;

  /**
   * Name of the secret to get the property from.
   *
   * @schema DynaKubeV1Beta3SpecProxy#valueFrom
   */
  readonly valueFrom?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecProxy' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecProxy(obj: DynaKubeV1Beta3SpecProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'value': obj.value,
    'valueFrom': obj.valueFrom,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta3SpecTemplates
 */
export interface DynaKubeV1Beta3SpecTemplates {
  /**
   * @schema DynaKubeV1Beta3SpecTemplates#extensionExecutionController
   */
  readonly extensionExecutionController?: DynaKubeV1Beta3SpecTemplatesExtensionExecutionController;

  /**
   * @schema DynaKubeV1Beta3SpecTemplates#kspmNodeConfigurationCollector
   */
  readonly kspmNodeConfigurationCollector?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector;

  /**
   * Low-level configuration options for the LogMonitoring feature.
   *
   * @schema DynaKubeV1Beta3SpecTemplates#logMonitoring
   */
  readonly logMonitoring?: DynaKubeV1Beta3SpecTemplatesLogMonitoring;

  /**
   * @schema DynaKubeV1Beta3SpecTemplates#openTelemetryCollector
   */
  readonly openTelemetryCollector?: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollector;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplates' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplates(obj: DynaKubeV1Beta3SpecTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'extensionExecutionController': toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionController(obj.extensionExecutionController),
    'kspmNodeConfigurationCollector': toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector(obj.kspmNodeConfigurationCollector),
    'logMonitoring': toJson_DynaKubeV1Beta3SpecTemplatesLogMonitoring(obj.logMonitoring),
    'openTelemetryCollector': toJson_DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollector(obj.openTelemetryCollector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Add a custom properties file by providing it as a value or reference it from a secret
 * If referenced from a secret, make sure the key is called 'customProperties'
 *
 * @schema DynaKubeV1Beta3SpecActiveGateCustomProperties
 */
export interface DynaKubeV1Beta3SpecActiveGateCustomProperties {
  /**
   * Raw value for given property.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateCustomProperties#value
   */
  readonly value?: string;

  /**
   * Name of the secret to get the property from.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateCustomProperties#valueFrom
   */
  readonly valueFrom?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecActiveGateCustomProperties' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecActiveGateCustomProperties(obj: DynaKubeV1Beta3SpecActiveGateCustomProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'value': obj.value,
    'valueFrom': obj.valueFrom,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DynaKubeV1Beta3SpecActiveGateEnv
 */
export interface DynaKubeV1Beta3SpecActiveGateEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnv#valueFrom
   */
  readonly valueFrom?: DynaKubeV1Beta3SpecActiveGateEnvValueFrom;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecActiveGateEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecActiveGateEnv(obj: DynaKubeV1Beta3SpecActiveGateEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DynaKubeV1Beta3SpecActiveGateEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Define resources requests and limits for single ActiveGate pods
 *
 * @schema DynaKubeV1Beta3SpecActiveGateResources
 */
export interface DynaKubeV1Beta3SpecActiveGateResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateResources#claims
   */
  readonly claims?: DynaKubeV1Beta3SpecActiveGateResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeV1Beta3SpecActiveGateResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeV1Beta3SpecActiveGateResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeV1Beta3SpecActiveGateResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecActiveGateResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecActiveGateResources(obj: DynaKubeV1Beta3SpecActiveGateResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeV1Beta3SpecActiveGateResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeV1Beta3SpecActiveGateTolerations
 */
export interface DynaKubeV1Beta3SpecActiveGateTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeV1Beta3SpecActiveGateTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeV1Beta3SpecActiveGateTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecActiveGateTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecActiveGateTolerations(obj: DynaKubeV1Beta3SpecActiveGateTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraints
 */
export interface DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraints' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraints(obj: DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'labelSelector': toJson_DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta3SpecLogMonitoringIngestRuleMatchers
 */
export interface DynaKubeV1Beta3SpecLogMonitoringIngestRuleMatchers {
  /**
   * @schema DynaKubeV1Beta3SpecLogMonitoringIngestRuleMatchers#attribute
   */
  readonly attribute?: string;

  /**
   * @schema DynaKubeV1Beta3SpecLogMonitoringIngestRuleMatchers#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecLogMonitoringIngestRuleMatchers' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecLogMonitoringIngestRuleMatchers(obj: DynaKubeV1Beta3SpecLogMonitoringIngestRuleMatchers | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'attribute': obj.attribute,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The namespaces where you want Dynatrace Operator to inject enrichment.
 *
 * @schema DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelector
 */
export interface DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelector(obj: DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * dynatrace-webhook injects into application pods based on labeled namespaces.
 * Has an optional CSI driver per node via DaemonSet to provide binaries to pods.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoring
 */
export interface DynaKubeV1Beta3SpecOneAgentApplicationMonitoring {
  /**
   * Use a custom OneAgent CodeModule image to download binaries.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoring#codeModulesImage
   */
  readonly codeModulesImage?: string;

  /**
   * Define resources requests and limits for the initContainer. For details, see Managing resources for containers
   * (https://kubernetes.io/docs/concepts/configuration/manage-resources-containers).
   *
   * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoring#initResources
   */
  readonly initResources?: DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResources;

  /**
   * Applicable only for applicationMonitoring or cloudNativeFullStack configuration types. The namespaces where you want Dynatrace Operator to inject.
   * For more information, see Configure monitoring for namespaces and pods (https://www.dynatrace.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoring#namespaceSelector
   */
  readonly namespaceSelector?: DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelector;

  /**
   * Use a specific OneAgent CodeModule version. Defaults to the latest version from the Dynatrace cluster.
   *
   * @default the latest version from the Dynatrace cluster.
   * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoring#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentApplicationMonitoring' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentApplicationMonitoring(obj: DynaKubeV1Beta3SpecOneAgentApplicationMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'codeModulesImage': obj.codeModulesImage,
    'initResources': toJson_DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResources(obj.initResources),
    'namespaceSelector': toJson_DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelector(obj.namespaceSelector),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Has a single OneAgent per node via DaemonSet.
 * Injection is performed via the same OneAgent DaemonSet.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStack
 */
export interface DynaKubeV1Beta3SpecOneAgentClassicFullStack {
  /**
   * Add custom OneAgent annotations.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStack#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Set additional arguments to the OneAgent installer.
   * For available options, see Linux custom installation (https://www.dynatrace.com/support/help/setup-and-configuration/dynatrace-oneagent/installation-and-operation/linux/installation/customize-oneagent-installation-on-linux).
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStack#args
   */
  readonly args?: string[];

  /**
   * Disables automatic restarts of OneAgent pods in case a new version is available (https://www.dynatrace.com/support/help/setup-and-configuration/setup-on-container-platforms/kubernetes/get-started-with-kubernetes-monitoring#disable-auto).
   * Enabled by default.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStack#autoUpdate
   */
  readonly autoUpdate?: boolean;

  /**
   * Set the DNS Policy for OneAgent pods. For details, see Pods DNS Policy (https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy).
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStack#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * Set additional environment variables for the OneAgent pods.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStack#env
   */
  readonly env?: DynaKubeV1Beta3SpecOneAgentClassicFullStackEnv[];

  /**
   * Use a custom OneAgent image. Defaults to the latest image from the Dynatrace cluster.
   *
   * @default the latest image from the Dynatrace cluster.
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStack#image
   */
  readonly image?: string;

  /**
   * Your defined labels for OneAgent pods in order to structure workloads as desired.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStack#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Specify the node selector that controls on which nodes OneAgent will be deployed.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStack#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
   * Note: resource.requests shows the values needed to run; resource.limits shows the maximum limits for the pod.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStack#oneAgentResources
   */
  readonly oneAgentResources?: DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResources;

  /**
   * Assign a priority class to the OneAgent pods. By default, no class is set.
   * For details, see Pod Priority and Preemption (https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/).
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStack#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The SecComp Profile that will be configured in order to run in secure computing mode.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStack#secCompProfile
   */
  readonly secCompProfile?: string;

  /**
   * Tolerations to include with the OneAgent DaemonSet. For details, see Taints and Tolerations (https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/).
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStack#tolerations
   */
  readonly tolerations?: DynaKubeV1Beta3SpecOneAgentClassicFullStackTolerations[];

  /**
   * Use a specific OneAgent version. Defaults to the latest version from the Dynatrace cluster.
   *
   * @default the latest version from the Dynatrace cluster.
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStack#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentClassicFullStack' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStack(obj: DynaKubeV1Beta3SpecOneAgentClassicFullStack | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'args': obj.args?.map(y => y),
    'autoUpdate': obj.autoUpdate,
    'dnsPolicy': obj.dnsPolicy,
    'env': obj.env?.map(y => toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackEnv(y)),
    'image': obj.image,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'oneAgentResources': toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResources(obj.oneAgentResources),
    'priorityClassName': obj.priorityClassName,
    'secCompProfile': obj.secCompProfile,
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackTolerations(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Has a single OneAgent per node via DaemonSet.
 * dynatrace-webhook injects into application pods based on labeled namespaces.
 * Has a CSI driver per node via DaemonSet to provide binaries to pods.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack
 */
export interface DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack {
  /**
   * Add custom OneAgent annotations.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Set additional arguments to the OneAgent installer.
   * For available options, see Linux custom installation (https://www.dynatrace.com/support/help/setup-and-configuration/dynatrace-oneagent/installation-and-operation/linux/installation/customize-oneagent-installation-on-linux).
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack#args
   */
  readonly args?: string[];

  /**
   * Disables automatic restarts of OneAgent pods in case a new version is available (https://www.dynatrace.com/support/help/setup-and-configuration/setup-on-container-platforms/kubernetes/get-started-with-kubernetes-monitoring#disable-auto).
   * Enabled by default.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack#autoUpdate
   */
  readonly autoUpdate?: boolean;

  /**
   * Use a custom OneAgent CodeModule image to download binaries.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack#codeModulesImage
   */
  readonly codeModulesImage?: string;

  /**
   * Set the DNS Policy for OneAgent pods. For details, see Pods DNS Policy (https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy).
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * Set additional environment variables for the OneAgent pods.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack#env
   */
  readonly env?: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnv[];

  /**
   * Use a custom OneAgent image. Defaults to the latest image from the Dynatrace cluster.
   *
   * @default the latest image from the Dynatrace cluster.
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack#image
   */
  readonly image?: string;

  /**
   * Define resources requests and limits for the initContainer. For details, see Managing resources for containers
   * (https://kubernetes.io/docs/concepts/configuration/manage-resources-containers).
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack#initResources
   */
  readonly initResources?: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResources;

  /**
   * Your defined labels for OneAgent pods in order to structure workloads as desired.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Applicable only for applicationMonitoring or cloudNativeFullStack configuration types. The namespaces where you want Dynatrace Operator to inject.
   * For more information, see Configure monitoring for namespaces and pods (https://www.dynatrace.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack#namespaceSelector
   */
  readonly namespaceSelector?: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelector;

  /**
   * Specify the node selector that controls on which nodes OneAgent will be deployed.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
   * Note: resource.requests shows the values needed to run; resource.limits shows the maximum limits for the pod.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack#oneAgentResources
   */
  readonly oneAgentResources?: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResources;

  /**
   * Assign a priority class to the OneAgent pods. By default, no class is set.
   * For details, see Pod Priority and Preemption (https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/).
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The SecComp Profile that will be configured in order to run in secure computing mode.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack#secCompProfile
   */
  readonly secCompProfile?: string;

  /**
   * Tolerations to include with the OneAgent DaemonSet. For details, see Taints and Tolerations (https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/).
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack#tolerations
   */
  readonly tolerations?: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackTolerations[];

  /**
   * Use a specific OneAgent version. Defaults to the latest version from the Dynatrace cluster.
   *
   * @default the latest version from the Dynatrace cluster.
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack(obj: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStack | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'args': obj.args?.map(y => y),
    'autoUpdate': obj.autoUpdate,
    'codeModulesImage': obj.codeModulesImage,
    'dnsPolicy': obj.dnsPolicy,
    'env': obj.env?.map(y => toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnv(y)),
    'image': obj.image,
    'initResources': toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResources(obj.initResources),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'namespaceSelector': toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelector(obj.namespaceSelector),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'oneAgentResources': toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResources(obj.oneAgentResources),
    'priorityClassName': obj.priorityClassName,
    'secCompProfile': obj.secCompProfile,
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackTolerations(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Has a single OneAgent per node via DaemonSet.
 * Doesn't inject into application pods.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoring
 */
export interface DynaKubeV1Beta3SpecOneAgentHostMonitoring {
  /**
   * Add custom OneAgent annotations.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoring#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Set additional arguments to the OneAgent installer.
   * For available options, see Linux custom installation (https://www.dynatrace.com/support/help/setup-and-configuration/dynatrace-oneagent/installation-and-operation/linux/installation/customize-oneagent-installation-on-linux).
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoring#args
   */
  readonly args?: string[];

  /**
   * Disables automatic restarts of OneAgent pods in case a new version is available (https://www.dynatrace.com/support/help/setup-and-configuration/setup-on-container-platforms/kubernetes/get-started-with-kubernetes-monitoring#disable-auto).
   * Enabled by default.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoring#autoUpdate
   */
  readonly autoUpdate?: boolean;

  /**
   * Set the DNS Policy for OneAgent pods. For details, see Pods DNS Policy (https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy).
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoring#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * Set additional environment variables for the OneAgent pods.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoring#env
   */
  readonly env?: DynaKubeV1Beta3SpecOneAgentHostMonitoringEnv[];

  /**
   * Use a custom OneAgent image. Defaults to the latest image from the Dynatrace cluster.
   *
   * @default the latest image from the Dynatrace cluster.
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoring#image
   */
  readonly image?: string;

  /**
   * Your defined labels for OneAgent pods in order to structure workloads as desired.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoring#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Specify the node selector that controls on which nodes OneAgent will be deployed.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoring#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
   * Note: resource.requests shows the values needed to run; resource.limits shows the maximum limits for the pod.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoring#oneAgentResources
   */
  readonly oneAgentResources?: DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResources;

  /**
   * Assign a priority class to the OneAgent pods. By default, no class is set.
   * For details, see Pod Priority and Preemption (https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/).
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoring#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The SecComp Profile that will be configured in order to run in secure computing mode.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoring#secCompProfile
   */
  readonly secCompProfile?: string;

  /**
   * Tolerations to include with the OneAgent DaemonSet. For details, see Taints and Tolerations (https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/).
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoring#tolerations
   */
  readonly tolerations?: DynaKubeV1Beta3SpecOneAgentHostMonitoringTolerations[];

  /**
   * Use a specific OneAgent version. Defaults to the latest version from the Dynatrace cluster.
   *
   * @default the latest version from the Dynatrace cluster.
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoring#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentHostMonitoring' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoring(obj: DynaKubeV1Beta3SpecOneAgentHostMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'args': obj.args?.map(y => y),
    'autoUpdate': obj.autoUpdate,
    'dnsPolicy': obj.dnsPolicy,
    'env': obj.env?.map(y => toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringEnv(y)),
    'image': obj.image,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'oneAgentResources': toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResources(obj.oneAgentResources),
    'priorityClassName': obj.priorityClassName,
    'secCompProfile': obj.secCompProfile,
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringTolerations(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionController
 */
export interface DynaKubeV1Beta3SpecTemplatesExtensionExecutionController {
  /**
   * Adds additional annotations to the ExtensionExecutionController pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionController#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Defines name of ConfigMap containing custom configuration file
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionController#customConfig
   */
  readonly customConfig?: string;

  /**
   * Defines name of Secret containing certificates for custom extensions signature validation
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionController#customExtensionCertificates
   */
  readonly customExtensionCertificates?: string;

  /**
   * Overrides the default image
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionController#imageRef
   */
  readonly imageRef?: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerImageRef;

  /**
   * Adds additional labels for the ExtensionExecutionController pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionController#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Defines storage device
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionController#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaim;

  /**
   * Define resources' requests and limits for single ExtensionExecutionController pod
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionController#resources
   */
  readonly resources?: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResources;

  /**
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionController#tlsRefName
   */
  readonly tlsRefName?: string;

  /**
   * Set tolerations for the ExtensionExecutionController pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionController#tolerations
   */
  readonly tolerations?: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTolerations[];

  /**
   * Adds TopologySpreadConstraints for the ExtensionExecutionController pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionController#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraints[];

  /**
   * Selects EmptyDir volume to be storage device
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionController#useEphemeralVolume
   */
  readonly useEphemeralVolume?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesExtensionExecutionController' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionController(obj: DynaKubeV1Beta3SpecTemplatesExtensionExecutionController | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'customConfig': obj.customConfig,
    'customExtensionCertificates': obj.customExtensionCertificates,
    'imageRef': toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerImageRef(obj.imageRef),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'persistentVolumeClaim': toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaim(obj.persistentVolumeClaim),
    'resources': toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResources(obj.resources),
    'tlsRefName': obj.tlsRefName,
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraints(y)),
    'useEphemeralVolume': obj.useEphemeralVolume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector {
  /**
   * Adds additional annotations for the NodeConfigurationCollector pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Set additional arguments to the NodeConfigurationCollector pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector#args
   */
  readonly args?: string[];

  /**
   * Set additional environment variables for the NodeConfigurationCollector pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector#env
   */
  readonly env?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnv[];

  /**
   * Overrides the default image
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector#imageRef
   */
  readonly imageRef?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorImageRef;

  /**
   * Adds additional labels for the NodeConfigurationCollector pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Define the nodeAffinity for the DaemonSet of the NodeConfigurationCollector
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector#nodeAffinity
   */
  readonly nodeAffinity?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinity;

  /**
   * Specify the node selector that controls on which nodes NodeConfigurationCollector pods will be deployed.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * If specified, indicates the pod's priority. Name must be defined by creating a PriorityClass object with that
   * name. If not specified the setting will be removed from the DaemonSet.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Define resources' requests and limits for single NodeConfigurationCollector pod
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector#resources
   */
  readonly resources?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResources;

  /**
   * Set tolerations for the NodeConfigurationCollector pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector#tolerations
   */
  readonly tolerations?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorTolerations[];

  /**
   * Define the NodeConfigurationCollector daemonSet updateStrategy
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector#updateStrategy
   */
  readonly updateStrategy?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategy;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'args': obj.args?.map(y => y),
    'env': obj.env?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnv(y)),
    'imageRef': toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorImageRef(obj.imageRef),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'nodeAffinity': toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinity(obj.nodeAffinity),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'priorityClassName': obj.priorityClassName,
    'resources': toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResources(obj.resources),
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorTolerations(y)),
    'updateStrategy': toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategy(obj.updateStrategy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Low-level configuration options for the LogMonitoring feature.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoring
 */
export interface DynaKubeV1Beta3SpecTemplatesLogMonitoring {
  /**
   * Add custom annotations to the LogMonitoring pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoring#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Set additional arguments to the LogMonitoring main container
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoring#args
   */
  readonly args?: string[];

  /**
   * Sets DNS Policy for the LogMonitoring pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoring#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * Overrides the default image for the LogMonitoring pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoring#imageRef
   */
  readonly imageRef?: DynaKubeV1Beta3SpecTemplatesLogMonitoringImageRef;

  /**
   * Add custom labels to the LogMonitoring pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoring#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Node selector to control the selection of nodes for the LogMonitoring pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoring#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Assign a priority class to the LogMonitoring pods. By default, no class is set
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoring#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Define resources' requests and limits for all the LogMonitoring pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoring#resources
   */
  readonly resources?: DynaKubeV1Beta3SpecTemplatesLogMonitoringResources;

  /**
   * The SecComp Profile that will be configured in order to run in secure computing mode for the LogMonitoring pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoring#secCompProfile
   */
  readonly secCompProfile?: string;

  /**
   * Set tolerations for the LogMonitoring pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoring#tolerations
   */
  readonly tolerations?: DynaKubeV1Beta3SpecTemplatesLogMonitoringTolerations[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesLogMonitoring' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesLogMonitoring(obj: DynaKubeV1Beta3SpecTemplatesLogMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'args': obj.args?.map(y => y),
    'dnsPolicy': obj.dnsPolicy,
    'imageRef': toJson_DynaKubeV1Beta3SpecTemplatesLogMonitoringImageRef(obj.imageRef),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'priorityClassName': obj.priorityClassName,
    'resources': toJson_DynaKubeV1Beta3SpecTemplatesLogMonitoringResources(obj.resources),
    'secCompProfile': obj.secCompProfile,
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesLogMonitoringTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollector
 */
export interface DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollector {
  /**
   * Adds additional annotations to the OtelCollector pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollector#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Overrides the default image
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollector#imageRef
   */
  readonly imageRef?: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorImageRef;

  /**
   * Adds additional labels for the OtelCollector pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollector#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Number of replicas for your OtelCollector
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollector#replicas
   */
  readonly replicas?: number;

  /**
   * Define resources' requests and limits for single OtelCollector pod
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollector#resources
   */
  readonly resources?: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResources;

  /**
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollector#tlsRefName
   */
  readonly tlsRefName?: string;

  /**
   * Set tolerations for the OtelCollector pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollector#tolerations
   */
  readonly tolerations?: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTolerations[];

  /**
   * Adds TopologySpreadConstraints for the OtelCollector pods
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollector#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollector(obj: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'imageRef': toJson_DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorImageRef(obj.imageRef),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'replicas': obj.replicas,
    'resources': toJson_DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResources(obj.resources),
    'tlsRefName': obj.tlsRefName,
    'tolerations': obj.tolerations?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFrom
 */
export interface DynaKubeV1Beta3SpecActiveGateEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DynaKubeV1Beta3SpecActiveGateEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DynaKubeV1Beta3SpecActiveGateEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DynaKubeV1Beta3SpecActiveGateEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DynaKubeV1Beta3SpecActiveGateEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecActiveGateEnvValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecActiveGateEnvValueFrom(obj: DynaKubeV1Beta3SpecActiveGateEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'configMapKeyRef': toJson_DynaKubeV1Beta3SpecActiveGateEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DynaKubeV1Beta3SpecActiveGateEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DynaKubeV1Beta3SpecActiveGateEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DynaKubeV1Beta3SpecActiveGateEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeV1Beta3SpecActiveGateResourcesClaims
 */
export interface DynaKubeV1Beta3SpecActiveGateResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecActiveGateResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecActiveGateResourcesClaims(obj: DynaKubeV1Beta3SpecActiveGateResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta3SpecActiveGateResourcesLimits
 */
export class DynaKubeV1Beta3SpecActiveGateResourcesLimits {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecActiveGateResourcesLimits {
    return new DynaKubeV1Beta3SpecActiveGateResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecActiveGateResourcesLimits {
    return new DynaKubeV1Beta3SpecActiveGateResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeV1Beta3SpecActiveGateResourcesRequests
 */
export class DynaKubeV1Beta3SpecActiveGateResourcesRequests {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecActiveGateResourcesRequests {
    return new DynaKubeV1Beta3SpecActiveGateResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecActiveGateResourcesRequests {
    return new DynaKubeV1Beta3SpecActiveGateResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelector
 */
export interface DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelector(obj: DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelectorMatchExpressions
 */
export interface DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelectorMatchExpressions(obj: DynaKubeV1Beta3SpecMetadataEnrichmentNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Define resources requests and limits for the initContainer. For details, see Managing resources for containers
 * (https://kubernetes.io/docs/concepts/configuration/manage-resources-containers).
 *
 * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResources
 */
export interface DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResources#claims
   */
  readonly claims?: DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResources(obj: DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Applicable only for applicationMonitoring or cloudNativeFullStack configuration types. The namespaces where you want Dynatrace Operator to inject.
 * For more information, see Configure monitoring for namespaces and pods (https://www.dynatrace.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelector
 */
export interface DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelector(obj: DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnv
 */
export interface DynaKubeV1Beta3SpecOneAgentClassicFullStackEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnv#valueFrom
   */
  readonly valueFrom?: DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFrom;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentClassicFullStackEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackEnv(obj: DynaKubeV1Beta3SpecOneAgentClassicFullStackEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
 * Note: resource.requests shows the values needed to run; resource.limits shows the maximum limits for the pod.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResources
 */
export interface DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResources#claims
   */
  readonly claims?: DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResources(obj: DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackTolerations
 */
export interface DynaKubeV1Beta3SpecOneAgentClassicFullStackTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentClassicFullStackTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackTolerations(obj: DynaKubeV1Beta3SpecOneAgentClassicFullStackTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnv
 */
export interface DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnv#valueFrom
   */
  readonly valueFrom?: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFrom;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnv(obj: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Define resources requests and limits for the initContainer. For details, see Managing resources for containers
 * (https://kubernetes.io/docs/concepts/configuration/manage-resources-containers).
 *
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResources
 */
export interface DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResources#claims
   */
  readonly claims?: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResources(obj: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Applicable only for applicationMonitoring or cloudNativeFullStack configuration types. The namespaces where you want Dynatrace Operator to inject.
 * For more information, see Configure monitoring for namespaces and pods (https://www.dynatrace.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelector
 */
export interface DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelector(obj: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
 * Note: resource.requests shows the values needed to run; resource.limits shows the maximum limits for the pod.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResources
 */
export interface DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResources#claims
   */
  readonly claims?: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResources(obj: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackTolerations
 */
export interface DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackTolerations(obj: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnv
 */
export interface DynaKubeV1Beta3SpecOneAgentHostMonitoringEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnv#valueFrom
   */
  readonly valueFrom?: DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFrom;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentHostMonitoringEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringEnv(obj: DynaKubeV1Beta3SpecOneAgentHostMonitoringEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Resource settings for OneAgent container. Consumption of the OneAgent heavily depends on the workload to monitor. You can use the default settings in the CR.
 * Note: resource.requests shows the values needed to run; resource.limits shows the maximum limits for the pod.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResources
 */
export interface DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResources#claims
   */
  readonly claims?: DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResources(obj: DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringTolerations
 */
export interface DynaKubeV1Beta3SpecOneAgentHostMonitoringTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentHostMonitoringTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringTolerations(obj: DynaKubeV1Beta3SpecOneAgentHostMonitoringTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Overrides the default image
 *
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerImageRef
 */
export interface DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerImageRef {
  /**
   * Custom image repository
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerImageRef#repository
   */
  readonly repository?: string;

  /**
   * Indicates a tag of the image to use
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerImageRef#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerImageRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerImageRef(obj: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerImageRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Defines storage device
 *
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaim
 */
export interface DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaim {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaim#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaim#dataSource
   */
  readonly dataSource?: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaim#dataSourceRef
   */
  readonly dataSourceRef?: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaim#resources
   */
  readonly resources?: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaim#selector
   */
  readonly selector?: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaim#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaim#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaim#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaim#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaim' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaim(obj: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSource(obj.dataSource),
    'dataSourceRef': toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSourceRef(obj.dataSourceRef),
    'resources': toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResources(obj.resources),
    'selector': toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Define resources' requests and limits for single ExtensionExecutionController pod
 *
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResources
 */
export interface DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResources#claims
   */
  readonly claims?: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResources(obj: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTolerations
 */
export interface DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTolerations(obj: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraints
 */
export interface DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraints' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraints(obj: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'labelSelector': toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnv
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnv#valueFrom
   */
  readonly valueFrom?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFrom;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnv(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Overrides the default image
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorImageRef
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorImageRef {
  /**
   * Custom image repository
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorImageRef#repository
   */
  readonly repository?: string;

  /**
   * Indicates a tag of the image to use
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorImageRef#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorImageRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorImageRef(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorImageRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Define the nodeAffinity for the DaemonSet of the NodeConfigurationCollector
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinity
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinity(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Define resources' requests and limits for single NodeConfigurationCollector pod
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResources
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResources#claims
   */
  readonly claims?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResources(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorTolerations
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorTolerations(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Define the NodeConfigurationCollector daemonSet updateStrategy
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategy
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategy {
  /**
   * Rolling update config params. Present only if type = "RollingUpdate".
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategy#rollingUpdate
   */
  readonly rollingUpdate?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdate;

  /**
   * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
   *
   * @default RollingUpdate.
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategy' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategy(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'rollingUpdate': toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdate(obj.rollingUpdate),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Overrides the default image for the LogMonitoring pods
 *
 * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringImageRef
 */
export interface DynaKubeV1Beta3SpecTemplatesLogMonitoringImageRef {
  /**
   * Custom image repository
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringImageRef#repository
   */
  readonly repository?: string;

  /**
   * Indicates a tag of the image to use
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringImageRef#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesLogMonitoringImageRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesLogMonitoringImageRef(obj: DynaKubeV1Beta3SpecTemplatesLogMonitoringImageRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Define resources' requests and limits for all the LogMonitoring pods
 *
 * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringResources
 */
export interface DynaKubeV1Beta3SpecTemplatesLogMonitoringResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringResources#claims
   */
  readonly claims?: DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesLogMonitoringResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesLogMonitoringResources(obj: DynaKubeV1Beta3SpecTemplatesLogMonitoringResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringTolerations
 */
export interface DynaKubeV1Beta3SpecTemplatesLogMonitoringTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesLogMonitoringTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesLogMonitoringTolerations(obj: DynaKubeV1Beta3SpecTemplatesLogMonitoringTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Overrides the default image
 *
 * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorImageRef
 */
export interface DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorImageRef {
  /**
   * Custom image repository
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorImageRef#repository
   */
  readonly repository?: string;

  /**
   * Indicates a tag of the image to use
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorImageRef#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorImageRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorImageRef(obj: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorImageRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Define resources' requests and limits for single OtelCollector pod
 *
 * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResources
 */
export interface DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResources#claims
   */
  readonly claims?: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResources(obj: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTolerations
 */
export interface DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTolerations(obj: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraints
 */
export interface DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraints' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraints(obj: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'labelSelector': toJson_DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFromConfigMapKeyRef
 */
export interface DynaKubeV1Beta3SpecActiveGateEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecActiveGateEnvValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecActiveGateEnvValueFromConfigMapKeyRef(obj: DynaKubeV1Beta3SpecActiveGateEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFromFieldRef
 */
export interface DynaKubeV1Beta3SpecActiveGateEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecActiveGateEnvValueFromFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecActiveGateEnvValueFromFieldRef(obj: DynaKubeV1Beta3SpecActiveGateEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFromResourceFieldRef
 */
export interface DynaKubeV1Beta3SpecActiveGateEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DynaKubeV1Beta3SpecActiveGateEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecActiveGateEnvValueFromResourceFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecActiveGateEnvValueFromResourceFieldRef(obj: DynaKubeV1Beta3SpecActiveGateEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFromSecretKeyRef
 */
export interface DynaKubeV1Beta3SpecActiveGateEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecActiveGateEnvValueFromSecretKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecActiveGateEnvValueFromSecretKeyRef(obj: DynaKubeV1Beta3SpecActiveGateEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: DynaKubeV1Beta3SpecActiveGateTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesClaims
 */
export interface DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesClaims(obj: DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesLimits
 */
export class DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesLimits {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesLimits {
    return new DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesLimits {
    return new DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesRequests
 */
export class DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesRequests {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesRequests {
    return new DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesRequests {
    return new DynaKubeV1Beta3SpecOneAgentApplicationMonitoringInitResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions
 */
export interface DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions(obj: DynaKubeV1Beta3SpecOneAgentApplicationMonitoringNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFrom
 */
export interface DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFrom(obj: DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'configMapKeyRef': toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesClaims
 */
export interface DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesClaims(obj: DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesLimits
 */
export class DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesLimits {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesLimits {
    return new DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesLimits {
    return new DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesRequests
 */
export class DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesRequests {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesRequests {
    return new DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesRequests {
    return new DynaKubeV1Beta3SpecOneAgentClassicFullStackOneAgentResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFrom
 */
export interface DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFrom(obj: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'configMapKeyRef': toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesClaims
 */
export interface DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesClaims(obj: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesLimits
 */
export class DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesLimits {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesLimits {
    return new DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesLimits {
    return new DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesRequests
 */
export class DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesRequests {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesRequests {
    return new DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesRequests {
    return new DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackInitResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions
 */
export interface DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions(obj: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims
 */
export interface DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims(obj: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesLimits
 */
export class DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesLimits {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesLimits {
    return new DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesLimits {
    return new DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesRequests
 */
export class DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesRequests {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesRequests {
    return new DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesRequests {
    return new DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackOneAgentResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFrom
 */
export interface DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFrom(obj: DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'configMapKeyRef': toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesClaims
 */
export interface DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesClaims(obj: DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesLimits
 */
export class DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesLimits {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesLimits {
    return new DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesLimits {
    return new DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesRequests
 */
export class DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesRequests {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesRequests {
    return new DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesRequests {
    return new DynaKubeV1Beta3SpecOneAgentHostMonitoringOneAgentResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSource
 */
export interface DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSource' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSource(obj: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSourceRef
 */
export interface DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSourceRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSourceRef(obj: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResources
 */
export interface DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResources#limits
   */
  readonly limits?: { [key: string]: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResources#requests
   */
  readonly requests?: { [key: string]: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResourcesRequests };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResources(obj: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelector
 */
export interface DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelector#matchExpressions
   */
  readonly matchExpressions?: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelector(obj: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesClaims
 */
export interface DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesClaims(obj: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesLimits
 */
export class DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesLimits {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesLimits {
    return new DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesLimits {
    return new DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesRequests
 */
export class DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesRequests {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesRequests {
    return new DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesRequests {
    return new DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelector
 */
export interface DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelector(obj: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFrom
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFrom(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'configMapKeyRef': toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'preference': toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesClaims
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesClaims(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesLimits
 */
export class DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesLimits {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesLimits {
    return new DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesLimits {
    return new DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesRequests
 */
export class DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesRequests {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesRequests {
    return new DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesRequests {
    return new DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Rolling update config params. Present only if type = "RollingUpdate".
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdate
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdate {
  /**
   * The maximum number of nodes with an existing available DaemonSet pod that
   * can have an updated DaemonSet pod during during an update.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * This can not be 0 if MaxUnavailable is 0.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdate#maxSurge
   */
  readonly maxSurge?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdateMaxSurge;

  /**
   * The maximum number of DaemonSet pods that can be unavailable during the
   * update. Value can be an absolute number (ex: 5) or a percentage of total
   * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
   * number is calculated from percentage by rounding up.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdate#maxUnavailable
   */
  readonly maxUnavailable?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdateMaxUnavailable;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdate' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdate(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'maxSurge': obj.maxSurge?.value,
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesClaims
 */
export interface DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesClaims(obj: DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesLimits
 */
export class DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesLimits {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesLimits {
    return new DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesLimits {
    return new DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesRequests
 */
export class DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesRequests {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesRequests {
    return new DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesRequests {
    return new DynaKubeV1Beta3SpecTemplatesLogMonitoringResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesClaims
 */
export interface DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesClaims(obj: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesLimits
 */
export class DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesLimits {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesLimits {
    return new DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesLimits {
    return new DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesRequests
 */
export class DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesRequests {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesRequests {
    return new DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesRequests {
    return new DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelector
 */
export interface DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelector(obj: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DynaKubeV1Beta3SpecActiveGateEnvValueFromResourceFieldRefDivisor
 */
export class DynaKubeV1Beta3SpecActiveGateEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecActiveGateEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta3SpecActiveGateEnvValueFromResourceFieldRefDivisor(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecActiveGateEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta3SpecActiveGateEnvValueFromResourceFieldRefDivisor(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef
 */
export interface DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef(obj: DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromFieldRef
 */
export interface DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromFieldRef(obj: DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef
 */
export interface DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef(obj: DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef
 */
export interface DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef(obj: DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef
 */
export interface DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef(obj: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef
 */
export interface DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef(obj: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef
 */
export interface DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef(obj: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef
 */
export interface DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef(obj: DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef
 */
export interface DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef(obj: DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromFieldRef
 */
export interface DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromFieldRef(obj: DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef
 */
export interface DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef(obj: DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef
 */
export interface DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef(obj: DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResourcesLimits
 */
export class DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResourcesLimits {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResourcesLimits {
    return new DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResourcesLimits(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResourcesLimits {
    return new DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResourcesRequests
 */
export class DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResourcesRequests {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResourcesRequests {
    return new DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResourcesRequests(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResourcesRequests {
    return new DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelectorMatchExpressions
 */
export interface DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelectorMatchExpressions(obj: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerPersistentVolumeClaimSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: DynaKubeV1Beta3SpecTemplatesExtensionExecutionControllerTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromConfigMapKeyRef
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromConfigMapKeyRef(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromFieldRef
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromFieldRef(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromResourceFieldRef
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromResourceFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromResourceFieldRef(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromSecretKeyRef
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromSecretKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromSecretKeyRef(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The maximum number of nodes with an existing available DaemonSet pod that
 * can have an updated DaemonSet pod during during an update.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * This can not be 0 if MaxUnavailable is 0.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdateMaxSurge
 */
export class DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdateMaxSurge {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdateMaxSurge {
    return new DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdateMaxSurge(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdateMaxSurge {
    return new DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdateMaxSurge(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of DaemonSet pods that can be unavailable during the
 * update. Value can be an absolute number (ex: 5) or a percentage of total
 * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
 * number is calculated from percentage by rounding up.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdateMaxUnavailable
 */
export class DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdateMaxUnavailable {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdateMaxUnavailable {
    return new DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdateMaxUnavailable(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdateMaxUnavailable {
    return new DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorUpdateStrategyRollingUpdateMaxUnavailable(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: DynaKubeV1Beta3SpecTemplatesOpenTelemetryCollectorTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor
 */
export class DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta3SpecOneAgentClassicFullStackEnvValueFromResourceFieldRefDivisor(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor
 */
export class DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta3SpecOneAgentCloudNativeFullStackEnvValueFromResourceFieldRefDivisor(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor
 */
export class DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta3SpecOneAgentHostMonitoringEnvValueFromResourceFieldRefDivisor(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromResourceFieldRefDivisor
 */
export class DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromResourceFieldRefDivisor(value);
  }

  public static fromString(value: string): DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromResourceFieldRefDivisor {
    return new DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorEnvValueFromResourceFieldRefDivisor(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   *
   * @schema DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: DynaKubeV1Beta3SpecTemplatesKspmNodeConfigurationCollectorNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */


/**
 * EdgeConnect is the Schema for the EdgeConnect API
 *
 * @schema EdgeConnect
 */
export class EdgeConnect extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EdgeConnect"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dynatrace.com/v1alpha1',
    kind: 'EdgeConnect',
  };

  /**
   * Renders a Kubernetes manifest for "EdgeConnect".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EdgeConnectProps = {}): any {
    return {
      ...EdgeConnect.GVK,
      ...toJson_EdgeConnectProps(props),
    };
  }

  /**
   * Defines a "EdgeConnect" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EdgeConnectProps = {}) {
    super(scope, id, {
      ...EdgeConnect.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EdgeConnect.GVK,
      ...toJson_EdgeConnectProps(resolved),
    };
  }
}

/**
 * EdgeConnect is the Schema for the EdgeConnect API
 *
 * @schema EdgeConnect
 */
export interface EdgeConnectProps {
  /**
   * @schema EdgeConnect#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EdgeConnectSpec defines the desired state of EdgeConnect.
   *
   * @schema EdgeConnect#spec
   */
  readonly spec?: EdgeConnectSpec;

}

/**
 * Converts an object of type 'EdgeConnectProps' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectProps(obj: EdgeConnectProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EdgeConnectSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EdgeConnectSpec defines the desired state of EdgeConnect.
 *
 * @schema EdgeConnectSpec
 */
export interface EdgeConnectSpec {
  /**
   * Adds additional annotations to the EdgeConnect pods
   *
   * @schema EdgeConnectSpec#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Location of the Dynatrace API to connect to, including your specific environment UUID
   *
   * @schema EdgeConnectSpec#apiServer
   */
  readonly apiServer: string;

  /**
   * Enables automatic restarts of EdgeConnect pods in case a new version is available (the default value is: true)
   *
   * @schema EdgeConnectSpec#autoUpdate
   */
  readonly autoUpdate?: boolean;

  /**
   * Adds custom root certificate from a configmap. Put the certificate under certs within your configmap.
   *
   * @schema EdgeConnectSpec#caCertsRef
   */
  readonly caCertsRef?: string;

  /**
   * Pull secret for your private registry
   *
   * @schema EdgeConnectSpec#customPullSecret
   */
  readonly customPullSecret?: string;

  /**
   * Adds additional environment variables to the EdgeConnect pods
   *
   * @schema EdgeConnectSpec#env
   */
  readonly env?: EdgeConnectSpecEnv[];

  /**
   * Host patterns to be set in the tenant, only considered when provisioning is enabled.
   *
   * @schema EdgeConnectSpec#hostPatterns
   */
  readonly hostPatterns?: string[];

  /**
   * Restrict outgoing HTTP requests to your internal resources to specified hosts
   *
   * @schema EdgeConnectSpec#hostRestrictions
   */
  readonly hostRestrictions?: string;

  /**
   * Overrides the default image
   *
   * @schema EdgeConnectSpec#imageRef
   */
  readonly imageRef?: EdgeConnectSpecImageRef;

  /**
   * KubernetesAutomation enables Kubernetes Automation for Workflows
   *
   * @schema EdgeConnectSpec#kubernetesAutomation
   */
  readonly kubernetesAutomation?: EdgeConnectSpecKubernetesAutomation;

  /**
   * Adds additional labels to the EdgeConnect pods
   *
   * @schema EdgeConnectSpec#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Node selector to control the selection of nodes for the EdgeConnect pods
   *
   * @schema EdgeConnectSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * EdgeConnect uses the OAuth client to authenticate itself with the Dynatrace platform.
   *
   * @schema EdgeConnectSpec#oauth
   */
  readonly oauth: EdgeConnectSpecOauth;

  /**
   * General configurations for proxy settings.
   *
   * @schema EdgeConnectSpec#proxy
   */
  readonly proxy?: EdgeConnectSpecProxy;

  /**
   * Amount of replicas for your EdgeConnect (the default value is: 1)
   *
   * @schema EdgeConnectSpec#replicas
   */
  readonly replicas?: number;

  /**
   * Defines resources requests and limits for single pods
   *
   * @schema EdgeConnectSpec#resources
   */
  readonly resources?: EdgeConnectSpecResources;

  /**
   * ServiceAccountName that allows EdgeConnect to access the Kubernetes API
   *
   * @schema EdgeConnectSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * Sets tolerations for the EdgeConnect pods
   *
   * @schema EdgeConnectSpec#tolerations
   */
  readonly tolerations?: EdgeConnectSpecTolerations[];

  /**
   * Sets topology spread constraints for the EdgeConnect pods
   *
   * @schema EdgeConnectSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: EdgeConnectSpecTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'EdgeConnectSpec' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectSpec(obj: EdgeConnectSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'apiServer': obj.apiServer,
    'autoUpdate': obj.autoUpdate,
    'caCertsRef': obj.caCertsRef,
    'customPullSecret': obj.customPullSecret,
    'env': obj.env?.map(y => toJson_EdgeConnectSpecEnv(y)),
    'hostPatterns': obj.hostPatterns?.map(y => y),
    'hostRestrictions': obj.hostRestrictions,
    'imageRef': toJson_EdgeConnectSpecImageRef(obj.imageRef),
    'kubernetesAutomation': toJson_EdgeConnectSpecKubernetesAutomation(obj.kubernetesAutomation),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'oauth': toJson_EdgeConnectSpecOauth(obj.oauth),
    'proxy': toJson_EdgeConnectSpecProxy(obj.proxy),
    'replicas': obj.replicas,
    'resources': toJson_EdgeConnectSpecResources(obj.resources),
    'serviceAccountName': obj.serviceAccountName,
    'tolerations': obj.tolerations?.map(y => toJson_EdgeConnectSpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_EdgeConnectSpecTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema EdgeConnectSpecEnv
 */
export interface EdgeConnectSpecEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema EdgeConnectSpecEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged.
   *
   * @schema EdgeConnectSpecEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema EdgeConnectSpecEnv#valueFrom
   */
  readonly valueFrom?: EdgeConnectSpecEnvValueFrom;

}

/**
 * Converts an object of type 'EdgeConnectSpecEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectSpecEnv(obj: EdgeConnectSpecEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_EdgeConnectSpecEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Overrides the default image
 *
 * @schema EdgeConnectSpecImageRef
 */
export interface EdgeConnectSpecImageRef {
  /**
   * Custom EdgeConnect image repository
   *
   * @schema EdgeConnectSpecImageRef#repository
   */
  readonly repository?: string;

  /**
   * Indicates version of the EdgeConnect image to use
   *
   * @schema EdgeConnectSpecImageRef#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'EdgeConnectSpecImageRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectSpecImageRef(obj: EdgeConnectSpecImageRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * KubernetesAutomation enables Kubernetes Automation for Workflows
 *
 * @schema EdgeConnectSpecKubernetesAutomation
 */
export interface EdgeConnectSpecKubernetesAutomation {
  /**
   * Enables Kubernetes Automation for Workflows
   *
   * @schema EdgeConnectSpecKubernetesAutomation#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'EdgeConnectSpecKubernetesAutomation' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectSpecKubernetesAutomation(obj: EdgeConnectSpecKubernetesAutomation | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EdgeConnect uses the OAuth client to authenticate itself with the Dynatrace platform.
 *
 * @schema EdgeConnectSpecOauth
 */
export interface EdgeConnectSpecOauth {
  /**
   * Name of the secret that holds oauth clientId/secret
   *
   * @schema EdgeConnectSpecOauth#clientSecret
   */
  readonly clientSecret: string;

  /**
   * Token endpoint URL of Dynatrace SSO
   *
   * @schema EdgeConnectSpecOauth#endpoint
   */
  readonly endpoint: string;

  /**
   * Determines if the operator will create the EdgeConnect and light OAuth client on the cluster using the credentials provided. Requires more scopes than default behavior.
   *
   * @schema EdgeConnectSpecOauth#provisioner
   */
  readonly provisioner?: boolean;

  /**
   * URN identifying your account. You get the URN when creating the OAuth client
   *
   * @schema EdgeConnectSpecOauth#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'EdgeConnectSpecOauth' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectSpecOauth(obj: EdgeConnectSpecOauth | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'clientSecret': obj.clientSecret,
    'endpoint': obj.endpoint,
    'provisioner': obj.provisioner,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * General configurations for proxy settings.
 *
 * @schema EdgeConnectSpecProxy
 */
export interface EdgeConnectSpecProxy {
  /**
   * Secret name which contains the username and password used for authentication with the proxy, using the
   * "Basic" HTTP authentication scheme.
   *
   * @schema EdgeConnectSpecProxy#authRef
   */
  readonly authRef?: string;

  /**
   * Server address (hostname or IP address) of the proxy.
   *
   * @schema EdgeConnectSpecProxy#host
   */
  readonly host?: string;

  /**
   * NoProxy represents the NO_PROXY or no_proxy environment
   * variable. It specifies a string that contains comma-separated values
   * specifying hosts that should be excluded from proxying.
   *
   * @schema EdgeConnectSpecProxy#noProxy
   */
  readonly noProxy?: string;

  /**
   * Port of the proxy.
   *
   * @schema EdgeConnectSpecProxy#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'EdgeConnectSpecProxy' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectSpecProxy(obj: EdgeConnectSpecProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'authRef': obj.authRef,
    'host': obj.host,
    'noProxy': obj.noProxy,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Defines resources requests and limits for single pods
 *
 * @schema EdgeConnectSpecResources
 */
export interface EdgeConnectSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema EdgeConnectSpecResources#claims
   */
  readonly claims?: EdgeConnectSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EdgeConnectSpecResources#limits
   */
  readonly limits?: { [key: string]: EdgeConnectSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema EdgeConnectSpecResources#requests
   */
  readonly requests?: { [key: string]: EdgeConnectSpecResourcesRequests };

}

/**
 * Converts an object of type 'EdgeConnectSpecResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectSpecResources(obj: EdgeConnectSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_EdgeConnectSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema EdgeConnectSpecTolerations
 */
export interface EdgeConnectSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema EdgeConnectSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema EdgeConnectSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema EdgeConnectSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema EdgeConnectSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema EdgeConnectSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'EdgeConnectSpecTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectSpecTolerations(obj: EdgeConnectSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema EdgeConnectSpecTopologySpreadConstraints
 */
export interface EdgeConnectSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema EdgeConnectSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: EdgeConnectSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated.
   *
   * @schema EdgeConnectSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   *
   * @schema EdgeConnectSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   *
   * @schema EdgeConnectSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored.
   *
   * @schema EdgeConnectSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * @schema EdgeConnectSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   *
   * @schema EdgeConnectSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   *
   * @schema EdgeConnectSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'EdgeConnectSpecTopologySpreadConstraints' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectSpecTopologySpreadConstraints(obj: EdgeConnectSpecTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'labelSelector': toJson_EdgeConnectSpecTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema EdgeConnectSpecEnvValueFrom
 */
export interface EdgeConnectSpecEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema EdgeConnectSpecEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: EdgeConnectSpecEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema EdgeConnectSpecEnvValueFrom#fieldRef
   */
  readonly fieldRef?: EdgeConnectSpecEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema EdgeConnectSpecEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: EdgeConnectSpecEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema EdgeConnectSpecEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: EdgeConnectSpecEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'EdgeConnectSpecEnvValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectSpecEnvValueFrom(obj: EdgeConnectSpecEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'configMapKeyRef': toJson_EdgeConnectSpecEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_EdgeConnectSpecEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_EdgeConnectSpecEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_EdgeConnectSpecEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema EdgeConnectSpecResourcesClaims
 */
export interface EdgeConnectSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema EdgeConnectSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema EdgeConnectSpecResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'EdgeConnectSpecResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectSpecResourcesClaims(obj: EdgeConnectSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema EdgeConnectSpecResourcesLimits
 */
export class EdgeConnectSpecResourcesLimits {
  public static fromNumber(value: number): EdgeConnectSpecResourcesLimits {
    return new EdgeConnectSpecResourcesLimits(value);
  }

  public static fromString(value: string): EdgeConnectSpecResourcesLimits {
    return new EdgeConnectSpecResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema EdgeConnectSpecResourcesRequests
 */
export class EdgeConnectSpecResourcesRequests {
  public static fromNumber(value: number): EdgeConnectSpecResourcesRequests {
    return new EdgeConnectSpecResourcesRequests(value);
  }

  public static fromString(value: string): EdgeConnectSpecResourcesRequests {
    return new EdgeConnectSpecResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema EdgeConnectSpecTopologySpreadConstraintsLabelSelector
 */
export interface EdgeConnectSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EdgeConnectSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EdgeConnectSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EdgeConnectSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'EdgeConnectSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectSpecTopologySpreadConstraintsLabelSelector(obj: EdgeConnectSpecTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EdgeConnectSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema EdgeConnectSpecEnvValueFromConfigMapKeyRef
 */
export interface EdgeConnectSpecEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema EdgeConnectSpecEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EdgeConnectSpecEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema EdgeConnectSpecEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'EdgeConnectSpecEnvValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectSpecEnvValueFromConfigMapKeyRef(obj: EdgeConnectSpecEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema EdgeConnectSpecEnvValueFromFieldRef
 */
export interface EdgeConnectSpecEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EdgeConnectSpecEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EdgeConnectSpecEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'EdgeConnectSpecEnvValueFromFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectSpecEnvValueFromFieldRef(obj: EdgeConnectSpecEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema EdgeConnectSpecEnvValueFromResourceFieldRef
 */
export interface EdgeConnectSpecEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EdgeConnectSpecEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EdgeConnectSpecEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: EdgeConnectSpecEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EdgeConnectSpecEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'EdgeConnectSpecEnvValueFromResourceFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectSpecEnvValueFromResourceFieldRef(obj: EdgeConnectSpecEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema EdgeConnectSpecEnvValueFromSecretKeyRef
 */
export interface EdgeConnectSpecEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema EdgeConnectSpecEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EdgeConnectSpecEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema EdgeConnectSpecEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'EdgeConnectSpecEnvValueFromSecretKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectSpecEnvValueFromSecretKeyRef(obj: EdgeConnectSpecEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EdgeConnectSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface EdgeConnectSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EdgeConnectSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EdgeConnectSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EdgeConnectSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'EdgeConnectSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: EdgeConnectSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EdgeConnectSpecEnvValueFromResourceFieldRefDivisor
 */
export class EdgeConnectSpecEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): EdgeConnectSpecEnvValueFromResourceFieldRefDivisor {
    return new EdgeConnectSpecEnvValueFromResourceFieldRefDivisor(value);
  }

  public static fromString(value: string): EdgeConnectSpecEnvValueFromResourceFieldRefDivisor {
    return new EdgeConnectSpecEnvValueFromResourceFieldRefDivisor(value);
  }

  private constructor(public readonly value: number | string) {
  }
}


/**
 * EdgeConnect is the Schema for the EdgeConnect API
 *
 * @schema EdgeConnectV1Alpha2
 */
export class EdgeConnectV1Alpha2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EdgeConnectV1Alpha2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dynatrace.com/v1alpha2',
    kind: 'EdgeConnect',
  };

  /**
   * Renders a Kubernetes manifest for "EdgeConnectV1Alpha2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EdgeConnectV1Alpha2Props = {}): any {
    return {
      ...EdgeConnectV1Alpha2.GVK,
      ...toJson_EdgeConnectV1Alpha2Props(props),
    };
  }

  /**
   * Defines a "EdgeConnectV1Alpha2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EdgeConnectV1Alpha2Props = {}) {
    super(scope, id, {
      ...EdgeConnectV1Alpha2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EdgeConnectV1Alpha2.GVK,
      ...toJson_EdgeConnectV1Alpha2Props(resolved),
    };
  }
}

/**
 * EdgeConnect is the Schema for the EdgeConnect API
 *
 * @schema EdgeConnectV1Alpha2
 */
export interface EdgeConnectV1Alpha2Props {
  /**
   * @schema EdgeConnectV1Alpha2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EdgeConnectSpec defines the desired state of EdgeConnect.
   *
   * @schema EdgeConnectV1Alpha2#spec
   */
  readonly spec?: EdgeConnectV1Alpha2Spec;

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2Props' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2Props(obj: EdgeConnectV1Alpha2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EdgeConnectV1Alpha2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EdgeConnectSpec defines the desired state of EdgeConnect.
 *
 * @schema EdgeConnectV1Alpha2Spec
 */
export interface EdgeConnectV1Alpha2Spec {
  /**
   * Adds additional annotations to the EdgeConnect pods
   *
   * @schema EdgeConnectV1Alpha2Spec#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Location of the Dynatrace API to connect to, including your specific environment UUID
   *
   * @schema EdgeConnectV1Alpha2Spec#apiServer
   */
  readonly apiServer: string;

  /**
   * Enables automatic restarts of EdgeConnect pods in case a new version is available (the default value is: true)
   *
   * @schema EdgeConnectV1Alpha2Spec#autoUpdate
   */
  readonly autoUpdate?: boolean;

  /**
   * Adds custom root certificate from a configmap. Put the certificate under certs within your configmap.
   *
   * @schema EdgeConnectV1Alpha2Spec#caCertsRef
   */
  readonly caCertsRef?: string;

  /**
   * Pull secret for your private registry
   *
   * @schema EdgeConnectV1Alpha2Spec#customPullSecret
   */
  readonly customPullSecret?: string;

  /**
   * Adds additional environment variables to the EdgeConnect pods
   *
   * @schema EdgeConnectV1Alpha2Spec#env
   */
  readonly env?: EdgeConnectV1Alpha2SpecEnv[];

  /**
   * Host patterns to be set in the tenant, only considered when provisioning is enabled.
   *
   * @schema EdgeConnectV1Alpha2Spec#hostPatterns
   */
  readonly hostPatterns?: string[];

  /**
   * Restrict outgoing HTTP requests to your internal resources to specified hosts
   *
   * @schema EdgeConnectV1Alpha2Spec#hostRestrictions
   */
  readonly hostRestrictions?: string[];

  /**
   * Overrides the default image
   *
   * @schema EdgeConnectV1Alpha2Spec#imageRef
   */
  readonly imageRef?: EdgeConnectV1Alpha2SpecImageRef;

  /**
   * KubernetesAutomation enables Kubernetes Automation for Workflows
   *
   * @schema EdgeConnectV1Alpha2Spec#kubernetesAutomation
   */
  readonly kubernetesAutomation?: EdgeConnectV1Alpha2SpecKubernetesAutomation;

  /**
   * Adds additional labels to the EdgeConnect pods
   *
   * @schema EdgeConnectV1Alpha2Spec#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Node selector to control the selection of nodes for the EdgeConnect pods
   *
   * @schema EdgeConnectV1Alpha2Spec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * EdgeConnect uses the OAuth client to authenticate itself with the Dynatrace platform.
   *
   * @schema EdgeConnectV1Alpha2Spec#oauth
   */
  readonly oauth: EdgeConnectV1Alpha2SpecOauth;

  /**
   * General configurations for proxy settings.
   *
   * @schema EdgeConnectV1Alpha2Spec#proxy
   */
  readonly proxy?: EdgeConnectV1Alpha2SpecProxy;

  /**
   * Amount of replicas for your EdgeConnect (the default value is: 1)
   *
   * @schema EdgeConnectV1Alpha2Spec#replicas
   */
  readonly replicas?: number;

  /**
   * Defines resources requests and limits for single pods
   *
   * @schema EdgeConnectV1Alpha2Spec#resources
   */
  readonly resources?: EdgeConnectV1Alpha2SpecResources;

  /**
   * ServiceAccountName that allows EdgeConnect to access the Kubernetes API
   *
   * @schema EdgeConnectV1Alpha2Spec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * Sets tolerations for the EdgeConnect pods
   *
   * @schema EdgeConnectV1Alpha2Spec#tolerations
   */
  readonly tolerations?: EdgeConnectV1Alpha2SpecTolerations[];

  /**
   * Sets topology spread constraints for the EdgeConnect pods
   *
   * @schema EdgeConnectV1Alpha2Spec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: EdgeConnectV1Alpha2SpecTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2Spec' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2Spec(obj: EdgeConnectV1Alpha2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'apiServer': obj.apiServer,
    'autoUpdate': obj.autoUpdate,
    'caCertsRef': obj.caCertsRef,
    'customPullSecret': obj.customPullSecret,
    'env': obj.env?.map(y => toJson_EdgeConnectV1Alpha2SpecEnv(y)),
    'hostPatterns': obj.hostPatterns?.map(y => y),
    'hostRestrictions': obj.hostRestrictions?.map(y => y),
    'imageRef': toJson_EdgeConnectV1Alpha2SpecImageRef(obj.imageRef),
    'kubernetesAutomation': toJson_EdgeConnectV1Alpha2SpecKubernetesAutomation(obj.kubernetesAutomation),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
    'oauth': toJson_EdgeConnectV1Alpha2SpecOauth(obj.oauth),
    'proxy': toJson_EdgeConnectV1Alpha2SpecProxy(obj.proxy),
    'replicas': obj.replicas,
    'resources': toJson_EdgeConnectV1Alpha2SpecResources(obj.resources),
    'serviceAccountName': obj.serviceAccountName,
    'tolerations': obj.tolerations?.map(y => toJson_EdgeConnectV1Alpha2SpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_EdgeConnectV1Alpha2SpecTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema EdgeConnectV1Alpha2SpecEnv
 */
export interface EdgeConnectV1Alpha2SpecEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema EdgeConnectV1Alpha2SpecEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged.
   *
   * @schema EdgeConnectV1Alpha2SpecEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema EdgeConnectV1Alpha2SpecEnv#valueFrom
   */
  readonly valueFrom?: EdgeConnectV1Alpha2SpecEnvValueFrom;

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2SpecEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2SpecEnv(obj: EdgeConnectV1Alpha2SpecEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_EdgeConnectV1Alpha2SpecEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Overrides the default image
 *
 * @schema EdgeConnectV1Alpha2SpecImageRef
 */
export interface EdgeConnectV1Alpha2SpecImageRef {
  /**
   * Custom image repository
   *
   * @schema EdgeConnectV1Alpha2SpecImageRef#repository
   */
  readonly repository?: string;

  /**
   * Indicates a tag of the image to use
   *
   * @schema EdgeConnectV1Alpha2SpecImageRef#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2SpecImageRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2SpecImageRef(obj: EdgeConnectV1Alpha2SpecImageRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * KubernetesAutomation enables Kubernetes Automation for Workflows
 *
 * @schema EdgeConnectV1Alpha2SpecKubernetesAutomation
 */
export interface EdgeConnectV1Alpha2SpecKubernetesAutomation {
  /**
   * Enables Kubernetes Automation for Workflows
   *
   * @schema EdgeConnectV1Alpha2SpecKubernetesAutomation#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2SpecKubernetesAutomation' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2SpecKubernetesAutomation(obj: EdgeConnectV1Alpha2SpecKubernetesAutomation | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * EdgeConnect uses the OAuth client to authenticate itself with the Dynatrace platform.
 *
 * @schema EdgeConnectV1Alpha2SpecOauth
 */
export interface EdgeConnectV1Alpha2SpecOauth {
  /**
   * Name of the secret that holds oauth clientId/secret
   *
   * @schema EdgeConnectV1Alpha2SpecOauth#clientSecret
   */
  readonly clientSecret: string;

  /**
   * Token endpoint URL of Dynatrace SSO
   *
   * @schema EdgeConnectV1Alpha2SpecOauth#endpoint
   */
  readonly endpoint: string;

  /**
   * Determines if the operator will create the EdgeConnect and light OAuth client on the cluster using the credentials provided. Requires more scopes than default behavior.
   *
   * @schema EdgeConnectV1Alpha2SpecOauth#provisioner
   */
  readonly provisioner?: boolean;

  /**
   * URN identifying your account. You get the URN when creating the OAuth client
   *
   * @schema EdgeConnectV1Alpha2SpecOauth#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2SpecOauth' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2SpecOauth(obj: EdgeConnectV1Alpha2SpecOauth | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'clientSecret': obj.clientSecret,
    'endpoint': obj.endpoint,
    'provisioner': obj.provisioner,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * General configurations for proxy settings.
 *
 * @schema EdgeConnectV1Alpha2SpecProxy
 */
export interface EdgeConnectV1Alpha2SpecProxy {
  /**
   * Secret name which contains the username and password used for authentication with the proxy, using the
   * "Basic" HTTP authentication scheme.
   *
   * @schema EdgeConnectV1Alpha2SpecProxy#authRef
   */
  readonly authRef?: string;

  /**
   * Server address (hostname or IP address) of the proxy.
   *
   * @schema EdgeConnectV1Alpha2SpecProxy#host
   */
  readonly host?: string;

  /**
   * NoProxy represents the NO_PROXY or no_proxy environment
   * variable. It specifies a string that contains comma-separated values
   * specifying hosts that should be excluded from proxying.
   *
   * @schema EdgeConnectV1Alpha2SpecProxy#noProxy
   */
  readonly noProxy?: string;

  /**
   * Port of the proxy.
   *
   * @schema EdgeConnectV1Alpha2SpecProxy#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2SpecProxy' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2SpecProxy(obj: EdgeConnectV1Alpha2SpecProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'authRef': obj.authRef,
    'host': obj.host,
    'noProxy': obj.noProxy,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Defines resources requests and limits for single pods
 *
 * @schema EdgeConnectV1Alpha2SpecResources
 */
export interface EdgeConnectV1Alpha2SpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema EdgeConnectV1Alpha2SpecResources#claims
   */
  readonly claims?: EdgeConnectV1Alpha2SpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EdgeConnectV1Alpha2SpecResources#limits
   */
  readonly limits?: { [key: string]: EdgeConnectV1Alpha2SpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.
   *
   * @schema EdgeConnectV1Alpha2SpecResources#requests
   */
  readonly requests?: { [key: string]: EdgeConnectV1Alpha2SpecResourcesRequests };

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2SpecResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2SpecResources(obj: EdgeConnectV1Alpha2SpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'claims': obj.claims?.map(y => toJson_EdgeConnectV1Alpha2SpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]?.value}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema EdgeConnectV1Alpha2SpecTolerations
 */
export interface EdgeConnectV1Alpha2SpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema EdgeConnectV1Alpha2SpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema EdgeConnectV1Alpha2SpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema EdgeConnectV1Alpha2SpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict).
   *
   * @schema EdgeConnectV1Alpha2SpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema EdgeConnectV1Alpha2SpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2SpecTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2SpecTolerations(obj: EdgeConnectV1Alpha2SpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema EdgeConnectV1Alpha2SpecTopologySpreadConstraints
 */
export interface EdgeConnectV1Alpha2SpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema EdgeConnectV1Alpha2SpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated.
   *
   * @schema EdgeConnectV1Alpha2SpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   *
   * @schema EdgeConnectV1Alpha2SpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   *
   * @schema EdgeConnectV1Alpha2SpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored.
   *
   * @schema EdgeConnectV1Alpha2SpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * @schema EdgeConnectV1Alpha2SpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   *
   * @schema EdgeConnectV1Alpha2SpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   *
   * @schema EdgeConnectV1Alpha2SpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2SpecTopologySpreadConstraints' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2SpecTopologySpreadConstraints(obj: EdgeConnectV1Alpha2SpecTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'labelSelector': toJson_EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema EdgeConnectV1Alpha2SpecEnvValueFrom
 */
export interface EdgeConnectV1Alpha2SpecEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema EdgeConnectV1Alpha2SpecEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: EdgeConnectV1Alpha2SpecEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema EdgeConnectV1Alpha2SpecEnvValueFrom#fieldRef
   */
  readonly fieldRef?: EdgeConnectV1Alpha2SpecEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema EdgeConnectV1Alpha2SpecEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: EdgeConnectV1Alpha2SpecEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema EdgeConnectV1Alpha2SpecEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: EdgeConnectV1Alpha2SpecEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2SpecEnvValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2SpecEnvValueFrom(obj: EdgeConnectV1Alpha2SpecEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'configMapKeyRef': toJson_EdgeConnectV1Alpha2SpecEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_EdgeConnectV1Alpha2SpecEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_EdgeConnectV1Alpha2SpecEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_EdgeConnectV1Alpha2SpecEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema EdgeConnectV1Alpha2SpecResourcesClaims
 */
export interface EdgeConnectV1Alpha2SpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema EdgeConnectV1Alpha2SpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema EdgeConnectV1Alpha2SpecResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2SpecResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2SpecResourcesClaims(obj: EdgeConnectV1Alpha2SpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema EdgeConnectV1Alpha2SpecResourcesLimits
 */
export class EdgeConnectV1Alpha2SpecResourcesLimits {
  public static fromNumber(value: number): EdgeConnectV1Alpha2SpecResourcesLimits {
    return new EdgeConnectV1Alpha2SpecResourcesLimits(value);
  }

  public static fromString(value: string): EdgeConnectV1Alpha2SpecResourcesLimits {
    return new EdgeConnectV1Alpha2SpecResourcesLimits(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema EdgeConnectV1Alpha2SpecResourcesRequests
 */
export class EdgeConnectV1Alpha2SpecResourcesRequests {
  public static fromNumber(value: number): EdgeConnectV1Alpha2SpecResourcesRequests {
    return new EdgeConnectV1Alpha2SpecResourcesRequests(value);
  }

  public static fromString(value: string): EdgeConnectV1Alpha2SpecResourcesRequests {
    return new EdgeConnectV1Alpha2SpecResourcesRequests(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelector
 */
export interface EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelector(obj: EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema EdgeConnectV1Alpha2SpecEnvValueFromConfigMapKeyRef
 */
export interface EdgeConnectV1Alpha2SpecEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema EdgeConnectV1Alpha2SpecEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EdgeConnectV1Alpha2SpecEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema EdgeConnectV1Alpha2SpecEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2SpecEnvValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2SpecEnvValueFromConfigMapKeyRef(obj: EdgeConnectV1Alpha2SpecEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema EdgeConnectV1Alpha2SpecEnvValueFromFieldRef
 */
export interface EdgeConnectV1Alpha2SpecEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EdgeConnectV1Alpha2SpecEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EdgeConnectV1Alpha2SpecEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2SpecEnvValueFromFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2SpecEnvValueFromFieldRef(obj: EdgeConnectV1Alpha2SpecEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema EdgeConnectV1Alpha2SpecEnvValueFromResourceFieldRef
 */
export interface EdgeConnectV1Alpha2SpecEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EdgeConnectV1Alpha2SpecEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EdgeConnectV1Alpha2SpecEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: EdgeConnectV1Alpha2SpecEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EdgeConnectV1Alpha2SpecEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2SpecEnvValueFromResourceFieldRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2SpecEnvValueFromResourceFieldRef(obj: EdgeConnectV1Alpha2SpecEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema EdgeConnectV1Alpha2SpecEnvValueFromSecretKeyRef
 */
export interface EdgeConnectV1Alpha2SpecEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema EdgeConnectV1Alpha2SpecEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EdgeConnectV1Alpha2SpecEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema EdgeConnectV1Alpha2SpecEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2SpecEnvValueFromSecretKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2SpecEnvValueFromSecretKeyRef(obj: EdgeConnectV1Alpha2SpecEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: EdgeConnectV1Alpha2SpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EdgeConnectV1Alpha2SpecEnvValueFromResourceFieldRefDivisor
 */
export class EdgeConnectV1Alpha2SpecEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): EdgeConnectV1Alpha2SpecEnvValueFromResourceFieldRefDivisor {
    return new EdgeConnectV1Alpha2SpecEnvValueFromResourceFieldRefDivisor(value);
  }

  public static fromString(value: string): EdgeConnectV1Alpha2SpecEnvValueFromResourceFieldRefDivisor {
    return new EdgeConnectV1Alpha2SpecEnvValueFromResourceFieldRefDivisor(value);
  }

  private constructor(public readonly value: number | string) {
  }
}

